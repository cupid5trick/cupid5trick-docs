8/16/2023

ffmpeg 命令行文档: <https://ffmpeg.org/ffmpeg.html>

# 媒体处理流程

`ffmpeg` 命令的基本语法为：

```bash
ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...
```

`ffmpeg` 中的视频文件是一个容器，容器有不同的封装格式。根据封装格式的不同，视频文件可以支持不同数量的视频、音频、字幕、附件等媒体流。

`ffmpeg` 处理视频媒体文件时，先从容器格式中抽取编码的媒体流，再根据不同媒体格式协议解码成裸流，这个过程就是“解复用=>解码”。针对裸流处理完成后，将其编码成媒体流，再放进输出的容器格式中，就得到输出的视频文件。整个处理过程就是“解复用=>解码=>流处理=>编码=>复用”：

```
 _______              ______________
|       |            |              |
| input |  demuxer   | encoded data |   decoder
| file  | ---------> | packets      | -----+
|_______|            |______________|      |
                                           v
                                       _________
                                      |         |
                                      | decoded |
                                      | frames  |
                                      |_________|
 ________             ______________       |
|        |           |              |      |
| output | <-------- | encoded data | <----+
| file   |   muxer   | packets      |   encoder
|________|           |______________|

```

`ffmpeg`调用 `libavformat` 库（包含解复用器）来读取输入文件并从中获取包含编码数据的数据包。当有多个输入文件时，`ffmpeg`尝试通过跟踪任何活动输入流上的最低时间戳来保持它们同步。

然后，编码的数据包被传递到解码器（除非为流选择了流复制，请参阅进一步的描述）。解码器生成未压缩的帧（原始视频/PCM 音频/...），可以通过过滤进一步处理（参见下一节）。过滤后，帧被传递到编码器，编码器对它们进行编码并输出编码后的数据包。最后，这些数据被传递到复用器，复用器将编码后的数据包写入输出文件。

# 过滤器

在上述媒体处理过程中，把原始未编码的媒体流进行编码之前，通常会有一个过滤操作。任何媒体处理都是通过过滤器在过滤阶段对无编码的原始媒体流操作的。

在编码前， `ffmpeg` 可以对raw（真实/原）音频和视频使用 `libavfilter` 库中的过滤器进行处理。多个过滤器按照前后依赖关系形成过滤图（`filtergraph`），过滤图又有简单过滤图和复杂过滤图之分。

- 简单过滤图是仅有一个输入和一个输出，并且**输入和输出的类型相同**
- 其他不属于简单过滤图的都是复杂过滤图

## 简单过滤图

通过 `-filter` 或者 `-vf` `-af` 设置视频流和音频流的过滤器。这个选项是一个输出选项，即针对单个输出文件设置的。

```
_________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                   _ | packets      |
|_________| \                  /||______________|
             \   __________   /
  simple     _\||          | /  encoder
  filtergraph   | filtered |/
                | frames   |
                |__________|

```

## 复杂过滤图

复杂的过滤图配置为`-filter_complex`选项，也可以使用等价的 `-lavfi` 选项。请注意，此选项是全局的，因为复杂的过滤器图本质上不能与单个流或文件明确关联。

```
 _________
|         |
| input 0 |\                    __________
|_________| \                  |          |
             \   _________    /| output 0 |
              \ |         |  / |__________|
 _________     \| complex | /
|         |     |         |/
| input 1 |---->| filter  |\
|_________|     |         | \   __________
               /| graph   |  \ |          |
              / |_________|   \| output 1 |
 _________   /                 |__________|
|         | /
| input 2 |/
|_________|

```

## 流复制

当提供了`-c|-codec copy` 选项时，`ffmpeg` 的工作流程是一个特殊情况。由于不需要解码、编码，`ffmpeg` 就会省略这两个过程，只改变容器层面的信息：例如改变容器（封装）格式、修改容器元数据等。

# 流的选择说明

默认情况下， `ffmpeg` 把输入文件每种类型（视频、音频和字幕）仅仅采用一个流转换输出到输出文件中，就是把最好效果的流进行输出：

- 对于视频，它是具有最高分辨率的流，
- 对于音频，它是具有最多通道的流，
- 对于字幕，这是找到的第一个字幕流，但有一个警告。输出格式的默认字幕编码器可以是基于文本的，也可以是基于图像的，并且只会选择相同类型的字幕流。

数据或附件流不会自动选择，只能通过 `-map` 选项将其包含到输出媒体中。

当然，你可以禁用默认设置，而采用 `-vn/-an/-sn` 选项进行专门的指定，如果要进行完全的手动控制，则是以 `-map` 选项，它将禁止默认值而选用指定的配置。

## 手动的流选择

在使用 `-map` 选项时，只有用户手动映射的流才被输出，除非还在 `filtergraph` 中定义了输出流。

## 复杂过滤图中的流选择

如果在复杂过滤图中存在没有打标签的输出流，这些流将被加入到第一个输出文件中。而如果第一个输出文件设置的格式不支持该输出流的类型，则会导致 `fatal error`。不提供 `-map` 选项时，这些无标签流的加入将使得 ffmpeg 跳过对应流类型的自动选择过程。如果提供了 `-map` 选项，除了该选项中手动定义的输出流之外，这些无标签流也会额外加入到输出文件中。

对于过滤图中带有标签的输出流，也要注意：在 `-map` 选项中这些有标签流必须且仅能被映射一次。

## 流处理

通常情况下，流处理过程都是独立于流选择过程的。流处理过程就是：通过 `-codec` 选项来对输出文件中的每个流设置相应的编码格式。通常情况下，在ffmpeg完成流选择过程之后才开始应用编码选项，因此无论流编码如何选择都不会影响流处理过程的执行顺利与否。如果不提供 `-codec`选项指定每个流类型的编码，ffmpeg则会选择注册在不同输出复用器（muxer）上的默认编码器。

这里要提到的字幕流处理场景，则不同于通常的流处理情形。如果我们给某个输出文件设定了字幕编码器，则必定选择第一个字幕流，不论它是文本类型的字幕流还是图片类型的字幕流。ffmpeg并不负责验证选中的字幕流能否转换为我们提供的编码，也不保证编码后的字幕流能否复用（封装）到目标输出文件中。

这也是ffmpeg中比较常见的原则：当用户手动设置编码器时，流选择过程无法检查编码流是否可以复用到输出文件中。如果不能，ffmpeg 将中止，所有输出文件都将无法处理。

# 示例

假设现在有 3 个输入文件，分别是：

```bash
input file 'A.avi'
      stream 0: video 640x360
      stream 1: audio 2 channels

input file 'B.mp4'
      stream 0: video 1920x1080
      stream 1: audio 2 channels
      stream 2: subtitles (text)
      stream 3: audio 5.1 channels
      stream 4: subtitles (text)

input file 'C.mkv'
      stream 0: video 1280x720
      stream 1: audio 2 channels
      stream 2: subtitles (image)
```

## 1: 自动流选择

```bash
ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov
```

这条命令指定了三个输出文件，前两个没有`-map`选项，因此 ffmpeg 会自动为这两个文件选择流。

输出 `1.mkv` 是一个 `Matroska` 容器文件，接受视频、音频和字幕流，因此 ffmpeg 将尝试选择每种类型之一。

- 对于视频，它将选择`B.mp4`中的 `stream 0`，因为它在所有输入视频流中具有最高分辨率。
- 对于音频，它将选择`B.mp4` 中的 `stream 3`，因为它拥有最多的通道。
- 对于字幕，它将选择`B.mp4` 中的 `stream 2`，这是`A.avi` 和 `B.mkv` 中的第一个字幕流。

输出`2.wav`仅接受音频流，因此只有来自 `B.mp4` 中的 `stream 3` 被选中。

对于输出`3.mov`，由于设置了 `-map` 选项，因此不会发生自动流选择。该`-map 1:a`选项将从第二个输入（即 ` B.mp4`）选择所有音频流。此输出文件中不会包含其他流。

对于前两个输出，所有包含的流都将被转码。选择的编码器将是每个输出格式注册的默认编码器，它可能与所选输入流的编解码器不匹配。

对于第三个输出，音频流的编解码器选项已设置为 `copy`，因此不会发生或可能发生解码-过滤-编码操作。所选流的数据包应从输入文件传送并在输出文件中复用。

## 2: 自动的字幕流选择

```bash
ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv
```

这条命令中，虽然 `out1.mkv` 是一个接受字幕流的 `Matroska` 容器文件，但是只有音频流和视频流会被选择。因为 `mkv` 封装格式的字幕是基于图像的，而 `Matroska` 复用器注册的默认字幕编码器则是基于文本的，对于该字幕流的转码操作预计会失败，因此该字幕流不会被选择。然而，在 `out2.mkv` 中通过 `-c:s` 选项设置了字幕编码器为 `dvdsub`，所以除了视频流以外还选中了字幕流。`-an` 选项的存在禁止了为 `out2.mkv` 自动选择音频流。

## 3: 无标签流的输出

```bash
ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex "overlay" out1.mp4 out2.srt
```

这条命令通过 `-filter_complex` 选项设置了全局的过滤图，仅有一个视频过滤器 `overlay` 构成。`overlay` 过滤器需要两个视频流作为输入，但是这里没有指定，因此在 `A.avi`、`B.mp4`、`C.mkv`中选择前两个可用的视频流。`overlay` 过滤器的输出流是无标签流，所以它的输出流将被复用到第一个文件 `out1.mp4`。同时，无标签流的存在使得视频流的自动选择过程被跳过（本来应该选择分辨率最高的`B:stream0`作为视频流输出）。根据自动流选择的规则，`B:stream3` 被选作音频输出流，字幕输出流未选择（因为 MP4封装格式没有注册默认的字幕编码器，命令中也没有手动设置字幕编码器）。

第二个输出文件 `out2.srt` 是文本字幕格式，因此自动流选择过程选择了 `B:stream2` 复用到 `out2.srt`。

## 4: 带标签流的输出

```bash
ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0[outv];overlay;aresample" \
       -map '[outv]' -an        out1.mp4 \
                                out2.mkv \
       -map '[outv]' -map 1:a:0 out3.mkv
```

上述这条命令会失败，因为 `[outv]` 输出流被映射了两次。所有输出文件都不会被处理。

```bash
ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0[outv];overlay;aresample" \
       -an        out1.mp4 \
                  out2.mkv \
       -map 1:a:0 out3.mkv

```

这条命令也会失败，因为 `hue` 过滤器的带标签输出流 `[outv]` 没有被映射。要记住复杂过滤图是一个全局选项，所以前面的命令应该这样修改：

```bash
ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex "[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample" \
        -map '[outv1]' -an        out1.mp4 \
                                  out2.mkv \
        -map '[outv2]' -map 1:a:0 out3.mkv

```

来自 `B.mp4` 的视频流将被发送到 `hue` 过滤器，它的输出流会被复制成两份 `[outv1]`和`[outv2]`，它们两个流分别被复用到 `out1.mp4` 和 `out3.mkv`。

`overlay` 从没有使用过的流中接收前两个视频流作为输入，即：`A.avi` 和 `C.mkv` 中的视频流。`overlay` 的输出流是无标签流，所以不管是否有 `-map` 选项存在都将被复用到 `out1.mp4`。

`aresample` 过滤器也是选择第一个未使用的音频流（即 `A.avi`），他的输出也是一个无标签流 ，将被复用到第一个输出文件 `out1.mp4`。`=an` 选项的存在只是禁用了输入流的自动选择过程，作为过滤图的输出流还是不受该选项的影响。`overlay` 和 `aresample` 的两个无标签输出流都会排在手动映射的 `[outv1]` 之前被复用到 `out1.mp4`。

`out2.mkv` 这个输出文件没有设置任何选项，所以进行完全的自动流选择。

`out3.mkv` 则包含两个 `-map` 选项所指定的 `[outv2]` 流和 `B:stream3` 的音频流。
