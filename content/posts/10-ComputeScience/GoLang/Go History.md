---
title: Untitled
author: cupid5trick
created: 2023-05-20 14:40
tags: 
categories: 
access: private
draft: false
lang:
- zh-cn
- en-us
abstract:
keywords:
---

# Go 语言起源

# 使用情况

# 设计理念

## Go 运行环境

Go 语言确实有一个可拓展库，叫做 runtime，它是每个 go 语言程序的一部分。Go 语言的 runtime 库实现了垃圾回收、并发、栈内存管理，以及其他的关键语言特性。尽管 Go runtime 提供了很多关键的语言特性，但它与 C 语言中的 libc 库更加类似。

因此使用 Go 语言必须牢牢把握，Go 语言并不像 Java runtime 一样提供了虚拟机。所有 Go 语言程序必须提前编译为本地机器代码才能在目标机器上运行。所以，尽管“runtime”一词通常用来描述运行在虚拟环境中的语言，在 Go 语言体系中 runtime 仅代表为 Go 语言提供关键语言特性的库。

## 类型系统：Go 是否有泛型？

Go 语言在 1.18 版本发布时增加了类型参数。类型系统中加入类型参数将使得多态或泛型编程在 Go 语言中成为可能。查阅 [Go语言标准](https://go.dev/ref/spec) 或 [Go 语言提案](https://go.dev/design/43651-type-parameters) 了解详情。

Go 语言在发行之处并不带有泛型特性。因为 Go 语言发明之初仅仅是为了能够编写易于长期维护 的服务端代码，所以 Go 语言一开始的设计理念就是围绕扩展性、可读性和并发性能展开的。多态和泛型编程在当时并不是 Go 语言要达成的核心目标，因此 Go 语言设计之初就为了简洁起见省略了多态特性。

泛型特性虽然方便，但是给类型系统和运行时处理带来了额外的复杂性。Go 语言经过一段时间的发展才研发出一套价值与其复杂性成比例的设计方案。

## 异常与断言：存废之争

传统的编程语言一般有异常处理和断言机制。以Java为例，编程人员常常在程序中 `try-catch-finally` 这样的语句表达异常处理逻辑，而断言在生产环境中则是默认关闭的（JVM默认关闭断言，通过虚拟机参数 `-ea`选项开启断言后才能在程序中正常使用断言功能）。相比Java这样“臃肿的”语言，Go直接宣布不支持断言，甚至使用一种截然不同的方式来支持错误处理。较为新奇，也需要广大程序员经过一定程度的了解与适应。

### 没有异常处理

Go 语言认为遵守常规的 `try-catch-finally` 范式，把异常处理耦合进控制流程中，会使得代码变得令人费解、难以维护。这种常规的异常处理范式也在鼓励程序员把太多不必要的情况标记为异常，例如：文件打开失败。

Go 语言采用一种不同的方法来处理普通异常。对于简单的错误处理，Go 语言的多返回值机制让编程人员不必过载函数的返回值即可轻松报告异常。查阅 [A canonical error type, coupled with Go's other features](https://go.dev/doc/articles/error_handling.html) 了解详情，Go 语言的错误处理轻松愉快，不过也因此和其他语言有很大不同。

Go 语言也有一些内置函数可以用来标志真正的意外情况，并从中恢复。错误恢复机制仅在发生错误后函数处于被挂起状态时，作为函数状态的一部分执行。这样的错误恢复机制已经足够处理程序真正的异常，并且不需要额外的控制流。如果利用得当，通过简洁的代码即可实现错误恢复功能。

查阅 [Defer, Panic, and Recover](https://go.dev/doc/articles/defer_panic_recover.html) 一文了解详情。另外，[Errors are values](https://blog.golang.org/errors-are-values) 这篇博客文章也描述了利用 Go 语言中异常也是值类型的特性，在 Go 语言中实现简洁的异常处理。

### 没有断言

Go 语言不提供断言机制。断言毫无疑问十分方便。但是我们从经验得出大部分程序员使用断言是为了避免考虑合理的错误处理和错误报告。合适的错误处理能让程序遇到非致命错误时继续运行，合适的错误报告意味着错误消息直击要害，避免程序员花费大量时间绞尽脑汁分析崩溃日志。精准的错误消息在程序员接触/运维不熟悉的代码时至关重要。

我们理解断言的存废是一个争议焦点。不过 Go 语言及其库中有很多要素并不符合现代工程实践，仅仅因为我们认为有时候不同的方法同样值得一试。

## 并发系统

并发性能是各种服务器程序和编程语言不断追求的宏伟目标。从过去到现在，工程实践中广泛使用的Java语言一直寻求将“轻量化线程”加入到成熟的Java体系中。以Fiber为代表的JDK开发项目组已经推出了测试版JDK，可惜要在生产中广泛使用的Java8中享受到轻量化线程的利好还遥遥无期。而Go语言作为“云原生语言”，设计之初就考虑到了轻量化线程的语言特性。

### 基于 CSP 思想构建并发系统

并发和多线程编程长久以来都被公认具有很高难度。我们认为部分原因是 [pthreads](https://en.wikipedia.org/wiki/POSIX_Threads) 等类库的复杂设计，以及 mutex（互斥锁）、条件变量、内存屏障等过于强调底层细节所致。更高层次的接口能够带来更简单的代码，即使在幕后仍然存在互斥锁等。

为并发提供高级语言支持的最成功模型之一来自 Hoare 的通信顺序过程（CSP）。Occam 和 Erlang 是两种源自 CSP 的著名语言。Go 的并发原语同样来自于 CSP 技术分支，采用通道支持进程间通信。在早期语言上的经验表明，CSP 通信模型非常适合面向过程的语言框架。

### 使用 Goroutine 代替线程

Goroutine 是使得 Go 语言并发易于使用的重要部分。其背后的协程思想已经流行了较长一段时间，核心思想就是在一组有限的线程之上复用众多独立执行单元（协程）。当一个协程由于阻塞式系统调用等原因阻塞时，Go runtime 自动把同一个操作系统线程上的其他协程切换到操作系统的其他可运行线程上，以避免一个协程阻塞导致其他协程也阻塞。更关键的部分在于程序员看不到协程背后的复杂机制。这使得 goroutine 极其轻量化：除去栈内存之外，内存开销只有几千字节。

为使占内存占用更小，Go runtime 采用了可调整大小的有界栈结构。新创建的 goroutine 通常只需要分配几千字节的空间：多数情况下都是足够的。如果发现内存不够，Go runtime 会自动调整用于储存协程栈的大小，让大量协程占用适量内存。平均用于内存管理的函数调用仅占用 3 个 CPU 指令左右。实践中，在同一个地址空间可以创建数十万协程。如果仅仅采用操作系统线程的话，系统资源早已用尽。

# 类型系统 // TODO

- [Frequently Asked Questions (FAQ) - The Go Programming Language](https://go.dev/doc/faq#types): <https://go.dev/doc/faq#types>

## 面向对象？

Go 语言可以说是面向对象编程语言，也可以说不是。Go 语言虽然有类型和方法，并且能够进行面向对象编程，但是 Go 语言没有类型间的显式依赖关系。Go 语言提供了与传统印象不一样的接口概念，不过开发者都认为这种接口更加易用并且在某些方面更加通用。也有与传统编程语言中子类类似的机制，可以在类型中嵌入其他类型。更重要的是，Go 语言中的方法比 C++ 或者 Java 中的方法更加普遍：可以给任何数据类型声明方法，即使是像整数之类的基本数据类型也可以声明方法。方法并不局限于结构体（或者说类型）。

此外，由于不存在类层次结构，Go 语言对象相比 C++ 或 Java 对象更加轻量化。

## 为什么没有类型继承？

面向对象编程，至少在最著名的传统编程语言中，都涉及到复杂的类型间关系。Go 语言的类型系统则与之不同。

相比传统编程语言要求程序员提前声明两个相互关联的类型，在 Go 语言中一个类型自动满足（satisfy）声明了相同方法的接口。除了减少书写工作量之外，这种隐式类层次结构是有实际好处的。类型可以同时满足多个接口，免去了传统编程语言中多继承的复杂性。接口因此也变得十分轻量化——可以用仅带有一个甚至 0 个方法的接口来表达一个概念。产生一个新想法或者需要测试时，可以事后按需添加新的接口，而不需要改动或者注释原有的代码。由于类型和接口之间不存在明确的关系，也就不需要讨论或维护类层次结构。

利用这种思想，可以构造出类型安全的 UNIX 管道。例如：`fmt.Fprintf` 可以打印到任意输出，不仅仅是文件；`bufio` 包可以和文件 IO 完全独立；`image` 包可以生成压缩的图片文件。所有这些成果都源于代表一个 `Write` 方法的 `io.Writer` 接口。上述还只是表面现象。Go 语言的接口对程序结构有深远的影响。

当然，这种隐式类型结构需要一定时间的适应，但它正是 Go 语言中最具生产力的部分。

## 静态链接？

Go 语言中动态分派方法的唯一来源就是接口。结构体或其他任何实体类型的方法一定是通过静态分派来解析。

## 为什么不支持重载方法或运算符？

如果方法分派时根本不需要进行类型匹配的话，语言实现层面就得到了极大的简化。从其他语言的经验中，我们了解到很多名字相同但签名不同的方法虽然偶尔有些作用，但在实践中常常令人困惑因而不利于项目长期稳定维护。仅通过方法名进行匹配，并要求参数类型一致是Go语言在类型系统中作出的重大简化。

至于运算符过载，该特性并不是一门编程语言不可或缺的功能，更多程度上是用来方便开发的语法工具。出于同样的理由，Go语言省略了这一特性：虽然运算符过载是一种便捷，但不提供运算符过载使得语言实现和性能优化更加简单。

## 如何保证类型“满足”接口？

你可以要求编译器通过尝试使用`T`的零值或`T`的空指针进行赋值，来检查类型`T`是否实现了接口`I`：

```Go
Type T struct{}
var _ I = T{}       // 验证T是否实现了I。
var _ I = (*T)(nil) // 验证*T是否实现了I。
```

如果`T`（或`*T`，相应地）没有实现`I`，这个错误将在编译时被捕获。

如果你希望一个接口的用户明确声明他们实现了这个接口，你可以在接口的方法集中添加一个带有描述性名称的方法。比如说

```Go
type Fooer 接口 {
    Foo()
    ImplementsFooer()
}
```

然后，一个类型必须实现`ImplementsFooer`方法才能成为`Fooer`，清楚地记录这一事实并在`go doc`的输出中公布。

```Go
type Bar struct{}
func (b Bar) ImplementsFooer() {}
func (b Bar) Foo() {}
```

大多数代码都不使用这种约束，因为它们限制了接口思想的效用。但有时，它们对于解决类似接口之间的歧义是必要的。

## 为什么不满足接口？

考虑用这个简单的接口来表示一个可以将自己与另一个值进行比较的对象：

```Go
type Equaler interface {
    Equal(Equaler) bool
}
```

和这个类型，`T`：

```Go
type T int
func (t T) Equal(u T) bool { return t == u }//不满足Equaler
```

与某些多态类型系统中的类似情况不同，`T`并没有实现`Equaler`。`T.Equal`的参数类型是`T`，而不是字面上所要求的`Equaler`类型。

在Go中，类型系统不提升`Equal`的参数；这是程序员的责任，如类型`T2`所说明的，它确实实现了`Equaler`：

```Go
type T2 int
func (t T2) Equal(u Equaler) bool { return t == u. (T2) }  //满足Equaler
```

不过，即使这样也和其他类型系统不同，因为**在Go中，任何满足`Equaler`的类型都可以作为参数传给`T2.Equal`，在运行时我们必须检查参数是否为`T2`类型**。有些语言在编译时就安排了这种保证。

一个相关的例子则是另一种情况：

```Go
type Opener interface {
   Open() Reader
}

func (t T3) Open() *os.File
```

在Go中，`T3`并不满足`Opener`，尽管它在其他语言中可能是这样。

虽然在这种情况下，Go的类型系统确实为程序员做了一些事情，但由于缺乏子类型，关于接口满足的规则非常容易说明：函数的名称和签名是否正是接口的名称和签名？Go的规则也很容易有效实现。我们觉得这些好处抵消了自动类型推广的不足。如果有一天Go采用了某种形式的多态类型，我们希望有一种方法来表达这些例子的想法，并让它们得到静态检查。

## 值传参 or 指针传参？

这是一个古老的值传参/指针传参问题，在Java中全部是指针传参，不过熟悉C语言的程序员对此应该十分了解。

```Go
func (s *MyStruct) pointerMethod() { }// 指针传参
func (s MyStruct) valueMethod() { } // 值传参
```

对于不习惯指针的程序员来说，这两个例子之间的区别可能会让人感到困惑，但实际上情况非常简单。当在一个类型上定义一个方法时，形参（上述例子中的`s`）的行为就像它是该方法的一个参数一样。那么，是把形参定义为一个值还是一个指针，就像一个函数参数应该是一个值还是一个指针一样，是同一个问题。这里有几个考虑因素。

首先，也是最重要的，方法是否需要修改形参？如果需要，那么形参必须是一个指针。(数组/切片和map作为引用，所以它们的情况更微妙一些。但是在一个方法中改变数组/切片的长度，形参仍然必须是一个指针。)在上面的例子中，如果`pointerMethod`修改了`s`的字段，那么调用者会看到这些变化，但是`valueMethod`是用调用者参数的副本来调用的（这就是传递值的定义），所以它所做的变化对调用者来说是不可见的。

顺便说一下，在Java中，方法接收者总是指针，尽管它们的指针性质在某种程度上被掩盖了（有一个建议是在语言中增加值接收者）。Go中的值形参才是不寻常的。

其次是对效率的考虑。如果形参很大，例如一个大的结构体，那么使用指针形参就会轻量很多。

再次是一致性。如果该类型的一些方法必须有指针形参，那么其他的也应该有，以便无论如何使用该类型，方法集都是一致的。详见关于[方法集](https://go.dev/doc/faq#different_method_sets)的章节。

对于基本类型、切片和小结构等类型，值形参是非常便宜的，所以除非方法的语义需要指针，否则值形参是高效且清晰的。

## 值类型与指针类型的方法集合

[Go语言标准](https://go.dev/ref/spec#Types)提到，值类型 `T`的方法集合只包含接收参数类型为值类型 `T`的方法，而指针类型`*T`的方法集合不仅包含接收指针类型`*T`的方法，还包括接收相应值类型参数的方法。也就是说`*T`类型的方法集合包含`T`类型的方法集合，反之则不成立。

这种区别之所以产生，是因为如果接口值包含指针`*T`，则方法调用可以通过取消引用指针来获取值，但是如果接口值包含值`T`，则方法调用没有安全的方法来获取指针。如果接口方法以指针传参，那么方法就能够修改接口内部的值，这在 Go语言标准中是不被允许的。

即使有些情况下方法同步编译器能够获取形参地址，通过这个地址修改接口的值，该变化也不会反映到调用方。例如，如果在 `bytes.Buffer`的 `Write`方法中通过值传参的方式尝试把标准输入的内容写入buffer，以下代码将会把标准输入的内容拷贝到 `buf`的一个副本，这并不符合我们期望的行为。

```Go
var buf bytes.Buffer
io.Copy(buf, os.Stdin)
```

## Goroutine 中的闭包

在使用闭包与并发时，可能会出现一些混淆。考虑一下下面的程序：

```Go
func main() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }

    // 等待所有的goroutines完成后再退出
    for _ = range values {
        <-done
    }
}
```

人们可能误以为会看到`a, b, c`作为输出。这是因为循环的每一次迭代都使用同一个变量`v`的实例，所以每个闭包都共享这个单一的变量。当闭包运行时，它打印的是执行 `fmt.Println` 时的 `v` 值，但 `v` 可能在 `goroutine` 启动后被修改过。为了帮助在问题发生之前检测到这个问题和其他问题，运行`go vet`。

为了在每个闭包启动时将`v`的当前值与之绑定，必须修改内循环以在每个迭代中创建一个新变量。一种方法是将该变量作为参数传递给闭包：

```Go
    for _, v := range values {
        go func(u string) {
            fmt.Println(u)
            done <- true
        }(v)
    }
```

在这个例子中，`v`的值被作为一个参数传递给匿名函数。然后，该值可以在函数中作为变量u被访问。

更简单的方法是直接创建一个新的变量，使用一种可能看起来很奇怪但在Go中很好用的声明方式：

```Go
    for _, v := range values {
        v := v // 创建一个新的'v'。
        go func() {
            fmt.Println(v)
            done <- true
        }()
    }
```

语言的这种行为，即不为每个迭代定义一个新的变量，回想起来可能是个错误。它可能会在以后的版本中得到解决，但为了兼容，在Go 1版本中不能改变。

# 值类型

## 隐式数值转换？

# 代码编写

# 指针与内存分配 // TODO

- [Frequently Asked Questions (FAQ) - The Go Programming Language](https://go.dev/doc/faq#Pointers): <https://go.dev/doc/faq#Pointers>

# 并发

# 控制流

# 类型参数

# 包和测试

# Go 语言实现

# 与 C 语言的不同
