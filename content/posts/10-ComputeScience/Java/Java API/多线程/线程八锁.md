## 什么是线程八锁？
所谓线程八锁实际上对应于是否加上synchronized，是否加上static等8种常见情况，代码如下:
1. 两个普通同步方法，两个线程，标准打印，结果：one two
2. 新增Thread.sleep()给getOne(),结果：one two
3. 新增普通方法getThree(),结果：three one two
4. 两个普通同步方法，两个对象，结果：two one
5. 修改getOne()为静态同步方法，结果：two one
6. 修改两个方法均为静态同步方法，一个对象，结果：one two
7. 一个静态同步方法，一个非静态同步方法，两个对象，结果：two one
8. 两个静态同步方法，两个对象，结果：one two

1.两个普通同步方法，两个线程，标准打印，结果：one two

```java
public class TestThread8Monitor {
    public static void main(String[] args) {
        final Number number = new Number();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                number.getOne();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number.getTwo();
            }
        }).start();
    }
}
class Number{
    public synchronized void getOne(){
        System.out.println("one");
    }
    public synchronized void getTwo(){
        System.out.println("Two");
    }
}
```

2.新增Thread.sleep()给getOne(),结果：one two

```java
public class TestThread8Monitor {
    public static void main(String[] args) {
        final Number number = new Number();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                number.getOne();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number.getTwo();
            }
        }).start();
    }
}
class Number{
    public synchronized void getOne(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("one");
    }
    public synchronized void getTwo(){
        System.out.println("Two");
    }
}
```

3.新增普通方法getThree(),结果：three one two

```java
public class TestThread8Monitor {
    public static void main(String[] args) {
        final Number number = new Number();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                number.getOne();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number.getTwo();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number.getThree();
            }
        }).start();
    }
}
class Number{
    public synchronized void getOne(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("one");
    }
    public synchronized void getTwo(){
        System.out.println("Two");
    }
    public void getThree(){
        System.out.println("Three");
    }
}
```

4.两个普通同步方法，两个对象，结果：two one

```java
public class TestThread8Monitor {
    public static void main(String[] args) {
        final Number number1 = new Number();
        final Number number2 = new Number();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                number1.getOne();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number2.getTwo();
            }
        }).start();
        
    }
}
class Number{
    public synchronized void getOne(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("one");
    }
    public synchronized void getTwo(){
        System.out.println("Two");
    }
}
```

5.修改getOne()为静态同步方法，结果：two one

```java
public class TestThread8Monitor {
    public static void main(String[] args) {
        final Number number1 = new Number();
        final Number number2 = new Number();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                number1.getOne();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number2.getTwo();
            }
        }).start();
        
    }
}
class Number{
    public static synchronized void getOne(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("one");
    }
    public synchronized void getTwo(){
        System.out.println("Two");
    }
}
```

6.修改两个方法均为静态同步方法，一个对象，结果：one two

```java
public class TestThread8Monitor {
    public static void main(String[] args) {
        final Number number1 = new Number();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                number1.getOne();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number1.getTwo();
            }
        }).start();
        
    }
}
class Number{
    public static synchronized void getOne(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("one");
    }
    public static synchronized void getTwo(){
        System.out.println("Two");
    }
}
```

7.一个静态同步方法，一个非静态同步方法，两个对象，结果：two one

```java
public class TestThread8Monitor {
    public static void main(String[] args) {
        final Number number1 = new Number();
        final Number number2 = new Number();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                number1.getOne();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number2.getTwo();
            }
        }).start();
        
    }
}
class Number{
    public static synchronized void getOne(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("one");
    }
    public  synchronized void getTwo(){
        System.out.println("Two");
    }
}
```

8.两个静态同步方法，两个对象，结果：one two

```java
public class TestThread8Monitor {
    public static void main(String[] args) {
        final Number number1 = new Number();
        final Number number2 = new Number();
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                number1.getOne();
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                number2.getTwo();
            }
        }).start();
        
    }
}
class Number{
    public static synchronized void getOne(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("one");
    }
    public static synchronized void getTwo(){
        System.out.println("Two");
    }
}
```

以上就是线程的八种常见的情况，线程八锁的关键在于：

非静态方法的锁默认为this，静态方法的锁为对应的class实例（这里是Number.class）  
某一个时刻内，只能有一个线程持有锁，无论有几个方法。

总结：
- 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其他的线程都只能等待，换句话说，某一时刻内，只能有唯一一个线程去访问这些synchronized方法。
- 锁的是当前对象this，被锁定后，其他线程都不能进入到当前对象的其他的synchronized方法。
- 加个普通方法后发现和同步锁无关。
- 换成静态同步方法后，情况又变化
- 所有的非静态同步方法用的都是同一把锁 -- 实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已经取锁的非静态同步方法释放锁就可以获取他们自己的锁。
- 所有的静态同步方法用的也是同一把锁 -- 类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间不会有竞争条件。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们是同一个实例对象