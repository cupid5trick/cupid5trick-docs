---
title: 自动内存管理
author: cupid5trick
created: 2022-07-03 00:22
tags: 
categories: 
access: private
draft: true
lang:
- zh-cn
- en-us
abstract:
keywords:
---


# 垃圾回收

## HotSpot 虚拟机垃圾回收优化指导

[HotSpot 虚拟机垃圾回收优化指导](HotSpot%20虚拟机垃圾回收优化指导.md)

// TODO 参考《深入理解 Java 虚拟机》第二部分 自动内存管理

## 概述

垃圾收集的历史远远比 Java 久远，在 1960 年诞生于麻省理工学院的 Lisp 是第一门开始使用内存动态分配和垃圾收集技术的语言。虽然内存动态分配和内存回收技术等自动内存管理已经相当成熟，但是当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就必须对这些自动化技术实施必要的监控和调节。

Java 堆和方法区这两个运行时数据区有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。

## 对象能否回收

Java 堆里面存放着 Java 中几乎所有对象实例，垃圾回收器在堆上进行垃圾回收时，第一件事就是判断这些对象哪些是存活的、那些已经死去，应当被回收。

### 引用计数算法

引用计数算法给每个对象增加一个引用计数器，每当有一个对象引用就把计数器加一、引用失效时就减一，任何时刻引用计数器为零时对象就是可以回收的。

引用计数算法虽然占用了一些额外的内存空间维护引用计数，但是原理简单，判定效率也很高，大多数情况下都是一个不错的算法。也有一些著名的应用案例：比如微软 COM（Component Object Model）技术、使用 ActionScript3 de FlashPlayer、Python 语言以及游戏脚本领域有很多应用的 Squirrel 都使用了引用计数算法进行内存管理。但是 Java 中简单的引用计数算法有很多例外情况需要考虑，必须配合大量额外处理才能保证正常工作。比如单纯的引用计数面对对象之间循环引用就会失效。

### 可达性分析算法

当前主流商用程序语言（Java、C# 到古老的 Lisp）的内存管理系统都是通过可达性分析算法来判断对象是否存活。这个算法的基本思路是通过一系列叫做 *GC Roots* 的跟对象作为起始节点集，根据引用关系向下搜索形成引用链，如果有对象到 *GC Roots* 之间没有任何引用链，这个对象就是可以回收的。

Java 中可以作为 *GC Roots* 的对象有以下几种：

- 在虚拟机栈的栈帧中局部变量表引用的对象，比如各线程被调方法中用到的参数、局部变量、临时变量等。
- 方法区中类静态属性引用的对象，比如 Java 类中引用类型的静态变量。
- 方法区中常量引用的对象，比如字符串常量池（String Table）里的引用。
- 本地方法栈中本地方法所引用的对象。
- Java 虚拟机内部的引用，比如基本数据类型对象的 Class 对象，一些常驻的异常对象（比如 `NullPointerException`、`OutOfMemoryError` 等），还有系统类加载器。
- 所有被同步锁（`synchronized` 关键字）所持有的对象。
- 反映 Java 虚拟机内部情况的 MXBean、JVMTI 中注册的回调、本地代码缓存等。

除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。譬如后文将会提到的分代收集和局部回收（Partial GC），如果只针对 Java 堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入 GC Roots 集合中去，才能保证可达性分析的正确性。

目前最新的几款垃圾收集器（如 OpenJDK 中的 G1、Shenandoah、ZGC 以及 Azul 的 PGC、C4 这些收集器）无一例外都具备了局部回收的特征，为了避免 GC Roots 包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。

### 引用的定义

*JDK 1.2* 之前 Java 引用还是采用传统的定义：如果 `reference` 类型的数值代表的是另一块内存的起始地址，就称这个 `reference` 数值代表某块内存、某个对象的引用。现在看来这种定义相对狭隘了，一个对象在这种定义之下只有被引用和未被引用两种状态。

*JDK 1.2* 之后 Java 的引用概念扩充为 强引用、软引用、弱引用和虚引用 4 种，4 种引用强度依次减弱。

- 强引用是最传统的引用定义，指的是程序代码中普遍存在的引用赋值。无论什么情况只要强引用关系存在，垃圾回收器永远不会回收被引用对象。
- **软引用** 用来描述一些还有用但非必须的对象。如果对象只被软引用关联，在系统将要发生内存溢出异常时，会把这些只有软引用的对象列入回收范围内进行第二次回收，如果这次回收还是没有获取足够的内存，才会抛出 `OutOfMemory` 异常。JDK 1.2 版之后提供了 SoftReference 类来实现软引用。
- **弱引用** 也用来描述非必需对象，但是强度比软引用更弱，被弱引用关联的对象只能生存到下次垃圾收集为止。垃圾收集过程中无论当前内存是否足够，都会回收只被弱引用关联的对象。JDK 1.2 版之后提供了 WeakReference 类来实现软引用。
- **虚引用** 也被称为“幽灵引用” 或“幻影引用”，是最弱的一种引用关系。一个对象是否存在虚引用，完全不影响这个对象生存时间，也无法通过虚引用获取对象实例。为对象设置虚引用的唯一目的就是能在对象被垃圾收集过程回收时得到系统通知。JDK 1.2 版之后提供了 PhantomReference 类来实现软引用。

简而言之，**强引用不回收、软引用内存不足即回收、弱引用发现即回收、虚引用用于对象回收跟踪**。

### 是否回收

可达性分析算法中即使是判定为不可达的对象，也不是一定会被回收。一个对象被回收至少要经历 **两次标记**：如果对象经过可达性分析之后发现和 *GC Roots* 之间没有引用链，会被第一次标记。随后根据对象是否有必要执行 `finalize` 方法进行一次筛选，如果对象没有覆写 `finalize` 方法、或者 `finalize` 方法已经被虚拟机调用过，虚拟机就会认为该对象没有必要执行 `finalize` 方法。

如果这个对象被判定为有必要执行 `finalize` 方法，那么该对象将被放入叫做 `F-Quene` 的队列中。后续虚拟机会自动建立一个低调度优先级的 *Finalizer* 线程执行队列中对象的 `finalize` 方法，但是虚拟机不会保证一定会等待析构方法执行结束。原因在于：如果某个对象的 `finalize` 方法执行缓慢、甚至发生了死循环，很可能导致 `F-Quene` 中其他对象一直处于等待状态，甚至导致内存回收系统崩溃。

`finalize` 方法是对象免于被回收的最后机会，虚拟机稍后会对 `F-Quene` 中的对象进行第二次小规模的标记，这些对象只要在 `finalize` 方法中重新与 *GC Roots* 建立引用链，再进行第二次标记时就会被移出将要回收对象的集合。比如在 `finalize` 方法中把自己（this 关键字）**赋给某个类变量或其他对象的成员变量**，这个对象就可以“逃脱”。这次之后，剩余的对象基本就要被回收了。

值得注意的是，因为 `finalize` 方法只会执行一次，因此对象免于被回收的机会也只有一次。下面这段代码可以验证这一点，两段相同的代码执行后，该对象只有第一次通过 `finalize` 方法被调用而“逃脱”，第二次却被回收：

```java
/**
* 此代码演示了两点：
* 1.对象可以在被GC时自我拯救。
* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
* @author zzm
*/
public class FinalizeEscapeGC {
	public static FinalizeEscapeGC SAVE_HOOK = null;
    public void isAlive() {
        System.out.println("yes, i am still alive :)");
    }
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }
    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();
        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead :(");
        }
        // 下面这段代码与上面的完全相同，但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead :(");
        }
    }
}
```

上述代码只是为了展示 Java 虚拟机的垃圾回收机制，实际并不鼓励通过 `finalize` 方法来拯救对象。`finalize` 方法并不等同于 C 和 C++ 语言的析构函数，而是 Java 诞生之初为使传统 C 和 C++ 程序员更容易接受 Java 而做出的妥协。因为 `finalize` 运行代价高昂、不确定性大、无法保证各对象 `finalize` 方法的调用顺序，如今已经被 Java 官方明确为不推荐的语法。尽管 `finalize` 方法具有 清理外部资源的功能，但是用 `try-finally` 或其他方式都可以实现的更好更及时。所以建议忘掉 `finalize` 方法。

### 方法区回收

《Java 虚拟机规范》提到可以不要求虚拟机在方法区实现垃圾回收，事实上确实有未实现或未完整实现方法区类型卸载的垃圾回收器存在，比如 JDK 11 的 ZGC 就不支持类型卸载。

方法区垃圾回收的性价比也比较低：在 Java 堆，尤其是新生代对常规应用进行一次垃圾回收通常可以回收 70% - 99% 的内存空间，但是方法区回收由于严苛的判定条件，垃圾回收效果往往远低于此。

方法区垃圾回收主要回收废弃的常量和不再使用的类型。回收废弃常量和 回收 Java 堆中的普通对象十分相似。但是判定一个类型是否不再适用，条件就比较苛刻：

- 该类的所有实例都已经被回收，Java 堆中不存在该类及其任何派生子类的对象
- 该类的类加载器已经被回收。这个条件除非是自己精心设计了替代系统类加载器的自定义类加载器，否则很难满足。
- 在任何地方都不存在该类对应的 `java.lang.Class` 对象的引用，无法在任何地方通过反射访问该类的方法。

对于满足上述三个条件的类型，Java 虚拟机允许对其进行回收，但并不是和对象一样没有引用就一定会被回收。对于是否进行类型卸载，HotSpot 虚拟机提供了 `-Xnoclassgc` 参数进行控制。还可以使用 `-verbose: class` 以及 `-XX: +TraceClassLoading`、`-XX: +TraceClassUnloading` 查看类加载和类卸载信息，`-verbose` 和 `-XX: +TraceClassLoading` 可以在 `product` 班的虚拟机使用，`-XX: +TraceClassUnloading` 需要 `FastDebug` 版的虚拟机支持。

在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 已经 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以免对方法区造成过大的内存压力。

## 3. 垃圾收集算法

这部分重点介绍分代收集理论和几种算法思想。从判定对象消亡的角度出发，垃圾收集器可以分为 引用计数式垃圾收集（Reference Counting GC）和 追踪式垃圾收集（Tracing GC），也常被称为直接垃圾收集和间接垃圾收集。

因为主流的 Java 虚拟机实现都没有用到 引用计数式垃圾收集，所以后续的所有算法思想和技术都属于追踪式垃圾收集的范畴。

### 3.1. 分代收集理论

**[3 Generations](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#sthref16)**

- [Performance Considerations](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#sthref19)
- [Measurement](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#sthref20)

**[4 Sizing the Generations](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#sizing_generations)**

- [Total Heap](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#sthref22)
- The Young Generation
  - [Survivor Space Sizing](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#sthref25)

#### 分代收集思想

Java 虚拟机的各种垃圾收集算法都结合了分代收集的思想。分代收集利用几个从观察大多数应用垃圾收集而得出的经验假说来最小化垃圾收集的工作量。

- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象生命周期都很短。
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集的对象消亡的可能性越小。

![Description of Figure 3-1 follows](Description_of_Figure_3-1_follows.png)

在分代收集的思想之下，形成了多种常用垃圾收集器一致的设计原则：把 Java 堆划分出不同的区域，根据对象在堆内存已分配空间大小方面定义的寿命分配到不同的内存区域保存。如果一个区域内大多数对象都是生命周期很短，把他们放在一起就可以只维护少量存活对象，从而以较低的代价回收到大量内存空间。如果剩下的都是生命周期很长的对象，虚拟机就可以以较低的频率回收这个区域。这样就同时兼顾了时间开销和内存空间的有效利用。

绝大多数对象都被分配在专供年轻对象的内存池（年轻代）中，年轻代内存用尽时，就发生一次仅针对年轻代对象的垃圾收集（Minor GC）。只要假设弱引用假说在年轻代成立，就可以只维护年轻代的少量存活对象，其余大部分对象都是可以回收的，这样充满无用对象的新生代就可以快速回收。

通常来自年轻代的部分存活对象在每次 Minor GC 都被移动到老年代。最终，老年代内存用尽后进行一次针对整个堆的内存回收，叫做 Major GC。Major GC 通常要比 Minor GC 花费的时间长，因为 Major GC 涉及的对象比 Minor GC 多得多。

在这种内存回收架构之下，就形成了如下的 HotSpot 堆内存布局：

![Description of Figure 3-2 follows](Description_of_Figure_3-2_follows.png)

一开始整个堆地址空间都被 Virtual 空间保留，但并没有被分配物理内存。为对象保留的堆地址空间可以分为年轻代和老年代。

年轻代由 Eden 和两个 Survivor 空间构成。大多数对象一开始都被分配在 Eden 空间。其中一个 Survivor 空间任何时刻都为空，作为 Eden 中存活对象的目的地；另一个 Survivor 空间是下次复制收集的目的地。普通对象将在两个 Survivor 空间中被来回拷贝，直到其足够进入老年代。

#### 跨代引用

在 HotSpot 源码中存在一些类似 `*Generation` 的实现，例如 `DefNewGeneration` 和 `ParNewGeneration` 等，这构成了 HotSpot 的 **分代式垃圾回收框架**。原本 HotSpot 鼓励开发者尽量在这个框架内开发新的垃圾收集器，但除了最早期的两组四款收集器之外，后来的开发者没有继续遵循。最根本的就是分代收集理论还在不断发展中，实现细节也有很多可以改进之处，被既定的代码框架约束反而不便。

实际上分代收集并不止划分内存区域那么简单，虽然把对象按照寿命划分了年轻代和老年代等区域，但对象并不是孤立的、对象之间会存在 **跨代引用**。想象一下现在进行一次只针对新生代的 Minor GC，但是新生代对象很可能被老年代对象引用，为了找出其中的存活对象不得不在 GC Roots 之外遍历整个老年代的所有对象，这就给垃圾回收带来极大负担。为了解决跨代引用带来的问题，就要引入第 3 条经验法则：

- 跨代引用假说 ( Intergenerational Reference Hypothesis )：跨代应用相对于铜带引用仅是极少数。

依据这条假说，在回收年轻代时就不应该为了识别少量的跨代引用而扫描整个老年代空间，也不必浪费空间专门记录每个对象是否存在以及存在哪些跨代引用，只需要在新生代建立一个全局数据结构，叫做记忆集（Rememered Set）。这个数据结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后发生 Minor GC 时，只有存在跨代引用的内存块中的对象会被加入到 GC Roots 进行扫描，虽然对象改变引用关系时需要维护记忆集，增加了一些运行时开销，但相比扫描整个老年代空间依然划算。

-----------------

#### 不同的垃圾收集行为

这里解释一些分代垃圾收集中的不同收集行为，整体来说包括整个堆空间的整体收集（Full GC）和 只针对某些部分堆空间的部分收集（Partial GC）。

在不同垃圾收集器中，又有各种部分收集的类似名词：

- 新生代收集（Minor GC/Young GC）：只针对新生代空间的垃圾收集。
- 老年代收集（Old GC）：只针对老年代的垃圾收集，目前只有 CMS 垃圾收集器有单独收集老年代的行为。Major GC 在有时会指老年代收集，需要根据上下文区分 Major GC 指的是老年代收集还是整体收集。
- 混合收集（Mixed GC）：针对整个新生代空间和部分老年代空间的垃圾收集。目前只有 G1 收集器属于这种行为。

### 3.2. 标记 - 清除算法

最早出现、也最基础的垃圾收集算法是标记清除算法（Mark-Sweep）算法，由 Lisp 创造者 John McCarthy 提出（1960）。首先标记所有需要回收的对象，然后统一回收被标记对象，也可以反过来标记存活对象、回收未被标记的对象。标记过程也就是判定对象是否存活的过程。

后续的垃圾收集算法大多是以 标记 - 清除算法为基础，对其缺点进行改进而得到。主要缺点有两个：

- 如果 Java 堆包含大量需要回收的对象，就需要进行大量的标记 - 清除动作，执行效率随着被回收对象数量的增长而降低。
- 内存空间碎片化。清楚之后产生大量不连续内存，如果内存碎片太多就会导致无法找到足够的连续内存而触发新的垃圾回收，很可能新一轮回收之后很快又触发下一轮垃圾回收。

### 3.3. 标记 - 复制算法

#### Semispace Copying

为了解决碎片化问题，Fenichel 提出一种叫做**半区复制（Semispace Copying）**的垃圾收集算法。把可用内存分成大小相等的两块，每次只使用其中一块。这一块用完以后就把存活对象复制到另一块，对当前块一次性全部清理为较大的一块连续内存。如果内存中存活对象的数量很大，就会有较大的复制开销，但对于多数对象可回收的情况，就即可以获取大块的连续内存、也不会有很高的复制代价。

标记 - 复制的缺陷也十分明显：

- 在存活对象居多时，会有很大的复制开销
- 牺牲了一半的可用内存

现在有很多 商用 Java 虚拟机优先采用标记 - 复制算法回收新生代，IBM 对新生代对象生命周期做了量化的观测：98% 的新生代对象熬不过第一轮垃圾收集。因此，不必按照相等的比例划分新生代内存空间。

#### HotSpot 新生代内存布局

1989 年 Andrew Appel 对 半区复制算法进行改进，现在称为 “Appel 式回收”。具体做法是把新生代划分为一块较大的 Eden 空间和两块较小的、大小相等的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生 Minor GC 时，把 Eden 和 源 Survivor 的存活对象复制到另一块 目的 Survivor 空间，然后直接清理 Eden 和 源 Survivor。经过一个轮次的 Minor GC，新生代可用内存就由 Eden 和原来的 目的 Survivor 空间构成。两块 Survivor 就这样轮换充当可用内存的一部分。

HotSpot 的 Serial、ParNew 等新生代收集器都采用了这种新生代布局。HotSpot 虚拟机默认设置 Eden 和 Survivor 大小之比 为 8 : 1，也就是新生代可用内存占 90%、浪费了 10%。

![image-20220108215803210](image-20220108215803210.png)

显然另一块 目的 Survivor 空间并不一定能容纳所有存活对象，出现这种情况时就进入到 **分配担保机制（Handle Promotion）**。

分配担保机制具体如下：

- 虚拟机在 Minor GC 之前会先检查一下老年代最大可用的连续空间是否大于新生代所有对象的空间之和，如果条件成立则这次 Minor GC 就是安全的，因为老年代空间内一定能找到一处足以容纳新生代存活对象的连续空间。
- 如果该条件不成立，就可能会确认一下老年代最大可用的连续空间是否大于历次进入老年代对象总和的平均大小（在通过 `-XX:HandlePromotionFailure` 参数设置为允许担保失败的情况下），尝试进行一次 Minor GC，这一次 Minor GC 是有风险的。
- 如果最大可用连续空间小于历史平均值，或者设置了不允许担保失败，就需要进行一次 Full GC。

这里和平均值比较是一种赌概率的办法，如果老年代内找不到一处连续空间来容纳所有进入老年代的新生代存活对象，也就不得不发起一次 Full GC。这种情况是代价最高的，先运行了一次 Minor GC，然后进行一次 Full GC。但是通常情况下都会设置 `-XX:HandlePromotionFailure` 为允许冒险，避免 Full GC 过于频繁。

-----------------------------

**注意**

在 JDK 6 Update 24 之后，`-XX:HandlePromotionFailure` 参数不再影响虚拟机 分配担保策略，只要老年代最大连续空间大于新生代进入老年代对象总大小的历史平均值，就会进行 Minor GC，否则进行 Full GC。

### 3.4. 标记 - 整理算法

因为标记 - 复制算法通常要求有额外内存空间作为担保，而且对象存活率高时复制开销也很大，所以在老年代不能采用这种算法。

针对老年代对象的存亡特征，1974 年 Edward Lueders 提出一种 **标记 - 整理算法（Mark-Compact）**。回收对象时，让所有存活对象向内存空间的一端移动，最后直接清理边界以外的空间。

标记 - 整理是一种移动式的垃圾回收算法，而是否移动存活对象也是一个优缺点并存的风险决策：

移动对象是一个代价极高的操作，并且更新对象引用时需要全程停止应用程序的执行（新的 ZGC 和 Shenandoah 收集器通过读屏障 Read Barrier 实现了整理过程和用户程序并发执行。标记 - 清除算法也需要停止用户线程来标记、清理存活对象，只是停顿时间很短）。但如果完全不移动存活对象，就需要更加复杂的内存分配器和内存访问器来解决内存碎片问题，新生代对象进入老年代时的内存分配效率也会受到影响。

从暂停时间的角度看，不移动暂停时间更短。但是从程序的吞吐量看，内存分配和内存访问的频率远高于内存回收，因此不移动对象带来的开销降低了整个程序的吞吐量。HotSpot 中关注吞吐量的 parallel Scavenge 收集器基于标记 - 整理，而关注延迟的 CMS 收集器则主要是基于 标记 - 清除。

还有一种折中的决定，也就是优先使用标记 - 清除算法，暂时容忍内存碎片。直到内存碎片已经影响到对象分配时，就使用标记 - 整理算法获取规整的内存空间。HotSpot 的 CMS 收集器就采用这种手段。

## 经典垃圾收集器

### Serial 收集器

Serial 是历史最悠久的收集器，曾是 HotSpot 虚拟机新生代收集器的唯一选择（JDK 1.3.1 之前）。这是一个单线程工作的收集器，它更显著的特征是垃圾收集时必须停止其他所有工作线程，直到收集结束。

从 JDK 1.3 开始，HotSpot 虚拟机开发团队为消除或者降低用户线程因垃圾收集而导致停顿的努力一直持续进行着，从 Serial 收集器到 Parallel 收集器，再到 Concurrent Mark Sweep（CMS）和 Garbage First（G1）收集器，最终至现在垃圾收集器的最前沿成果 Shenandoah 和 ZGC 等，我们看到了一个个越来越构思精巧，越来越优秀，也越来越复杂的垃圾收集器不断涌现，用户线程的停顿时间在持续缩短，但是仍然没有办法彻底消除（这里不讨论 RTSJ 中的收集器）。

实际上，Serial 至今依然是 HotSpot 运行在客户端模式下新生代收集器的默认选择。虽然停止应用线程听起来无法忍受，但 Serial 相比其他收集器的一个显著优点就是简单高效。在内存资源受限的环境，Serial 是所有收集器中额外内存消耗（Memory Footprint）最小的。对于单核或核心数较少的处理器，Serial 没有线程交互的开销，可以获得最高的单线程收集效率。

在用户桌面应用场景以及部分微服务应用中，分配给虚拟机管理的内存一般不会很大，回收几十到一两百兆大小的新生代空间，Serial 的停顿时间可以控制在最多一百毫秒以内。因此 Serial 是客户端模式虚拟机的很好选择。

### ParNew 收集器

ParNew 就是 Serial 收集器的多线程版本，其余的行为与 Serial 收集器完全一致，包括 Serial 的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都和 Serial 一致。

ParNew 与 Serial 相比除了支持多线程之外并没有太多创新，却是不少服务端模式 HotSpot 虚拟机（尤其是 JDK 7 之前一流系统）的首选新生代收集器。这里一个与功能和性能无关但很重要的原因就是：除了 Serial 之外只有 ParNew 可以和 CMS 配合工作。

> 除了 CMS 面向低延迟而 Parallel Scavenge 面向高吞吐量之外，技术上的原因是 Parallel 收集器以及后来的 G1 都没有在 HotSpot 原本分代框架下实现，Serial 和 ParNew 则是共用了这部分代码。

------------------------

JDK 5 发布时 HotSpot 推出了 CMS 收集器，这是第一款真正支持并发的收集器，让垃圾收集线程可以和应用线程基本上同时工作。但是 CMS 作为针对老年代的收集器，却无法和 JDK 1.4.0 的新生代处理器 Parallel Scavenge 配合工作，所以在 JDK 5 中 使用 CMS 时新生代收集器只能选择 ParNew 或 Serial 之一。ParNew 是通过 `-XX: +UseConcMarkSweepGC` 参数激活 CMS 之后默认的新生代收集器，也可以使用 `-XX: +/-UseParNewGC` 强制启用或禁用 ParNew 收集器。

CMS 老年代收集器巩固了 ParNew 的地位。后来更先进的 G1 是一个面向全堆的收集器，不需要和新生代收集器配合。所以从 JDK 9 之后 HotSpot 希望 G1 取代 ParNew+CMS 的方案，甚至取消了 ParNew+Serial Old 和 Serial+CMS 两种垃圾收集方案，并且取消了 `-XX: +UseParNewGC` 参数，这意味着 ParNew 并入 CMS 成为其专有的新生代收集器。ParNew 可以说从此退出 HotSpot 垃圾收集器的历史舞台。

#### 垃圾收集中的并发与并行

并发和并行在垃圾收集的上下文中含义不是很明确，可以如下理解：

- 并行（Parallel）：描述多个垃圾收集器线程之间的关系。并行说明同一时间有多个垃圾收集线程协同工作，通常默认应用线程处于等待状态。
- 并发（Concurrent）：描述垃圾收集器线程和应用线程之间的关系。说明垃圾收集器线程和用户线程可以同时运行。用户线程未被冻结所以程序依然能响应服务请求，但是受到垃圾收集器占用系统资源的影响，应用的吞吐量会有一定程度的下降。

### Parallel Scavenge 收集器

Parallel Scavenge 是基于标记 - 复制算法、面向高吞吐量的一款新生代收集器，也常被称作“吞吐量优先收集器”。CMS 等垃圾收集器关注的是尽可能缩短停顿时间。这里吞吐量的定义是用户代码的执行时间在系统总执行时间中的比例。如果垃圾收集的执行时间越少，那么系统服务用户程序的时间就越多，因此提供了更高的吞吐量。

Parallel Scavenge 有两个参数可以精细地控制吞吐量：最大暂停时间 `-XX:MaxGCPauseMillis` 和垃圾收集行为的时间占比 `-XX: GCTimeRatio`。

`-XX:MaxGCPauseMillis` 是一个大于 0 的毫秒数，收集器会在这个限制之下调整行为尽量缩短垃圾收集的暂停时间。`-XX:GCTimeRatio` 是一个 大于 0 小于 100 的整数，如果设为 19 允许的垃圾收集时间占比就是 (1/ (1 + 19)) 也就是 5%。`-XX:GCTimeRatio` 的默认值是 99。

垃圾收集器根据这些限制条件会对堆内存布局做出动态调整，比如低延迟很可能要求缩小新生代大小、高吞吐量则要求更大的新生代空间。提升任一个指标都是在牺牲另一个指标的条件下实现的。可以查看垃圾收集性能指标详细了解：[Behavior-Based Tuning](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref11)。

Parallel Scavenge 收集器还有一个 `-XX:+UseAdaptiveSizePolicy` 参数，这个开关被打开之后就不需要手工指定新生代大小（`-Xmn`）、Eden 和 Survivor 空间的比例（`-XX:SurvivorRatio`）、晋升老年代对象的垃圾回收轮次限制（`-XX:PretenureSizeThreshold`）等参数。虚拟机可以根据系统的性能监控数据，动态调整行为来提供最合适的暂停时间或吞吐量，这种行为叫做垃圾收集的自适应调节策略（[GC Ergonomics](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html)）。

使用自适应调节时，只需要通过 `-Xmx`、`-Xms` 设置最大或最小堆大小，然后使用 `-XX:MaxGCPauseMillis` 或 `-XX:GCTimeRatio` 设定吞吐量优化目标，Parallel Scavenge 可以自适应地调节其行为。

### Serial Old 收集器

Serial Old 是 Serial 收集器的老年代版本，同样以单线程工作、采用 **标记 - 整理算法**。Serial Old 的主要目的是供客户端模式的 HotSpot 虚拟机使用。

在服务端的虚拟机有两种可能的使用场景：在 JDK 5 及之前的版本中和 Parallel Scavenge 搭配使用，或者作为 CMS 收集器发生 Concurrent Mode Failure 时的预案使用。

> Parallel Scavenge 收集器中本身包含老年代收集器 PS MarkSweep，并非直接使用 Serial Old，但 PS MarkSweep 与 Serial Old 的实现几乎一样。所以很多地方都以 Serial Old 代表 PS MarkSweep。

### Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程，采用标记 - 整理算法。这个收集器是从 JDK 6 才开始提供的，在此之前如果选择了 Parallel Scavenge 作为新生代收集器，老年代收集器除 Serial Old ( PS MarkSweep ) 之外别无选择。而其他表现良好的老年代垃圾收集器（如 CMS）无法与其配合工作，再加上 Serial Old 收集器在服务端性能的拖累，Parallel Scavenge 整体上未必能取得最大吞吐量，而且单线程的老年代收集器无法充分利用服务器的多处理器性能，这种组合的吞吐量甚至不如 ParNew+CMS 方案。

直到 Parallel Old 出现，**吞吐量优先收集器** 才有了名副其实的搭配。**在注重吞吐量或者处理器资源较为稀缺的场景都可以优先考虑 Parallel Scavenge+Parallel Old 组合。**

### CMS 收集器

**[8 Concurrent Mark Sweep (CMS) Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector)**

- [Concurrent Mode Failure](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mode_failure)
- [Excessive GC Time and OutOfMemoryError](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref35)
- [Floating Garbage](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref36)
- [Pauses](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref37)
- [Concurrent Phases](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref38)
- [Starting a Concurrent Collection Cycle](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref39)
- [Scheduling Pauses](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref40)
- Incremental Mode
  - [Command-Line Options](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref41)
  - [Recommended Options](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#i_cms_recommended_options)
  - [Basic Troubleshooting](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref43)
- [Measurements](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#sthref45)

CMS ( Concurrent Mark Sweep ) 是一种注重低延迟的垃圾收集器。CMS 非常适合很多 B/S 系统的服务端应用，可以提供尽可能短的系统暂停时间、提升响应速度。

CMS 是基于 **标记 - 清除算法** 实现的，并且提供了让垃圾收集线程和用户线程能够基本同时运行的并发能力。CMS 垃圾收集过程包括四个步骤：

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

初始标记和重新标记两个步骤依然具有 *Stop The World* 的特征。**初始标记** 只标记 GC Roots 直接关联的对象，速度很快。**并发标记** 阶段就从被标记的直接关联对象开始遍历整个对象关系图，这个过程耗时较长但不需要停止用户线程。**重新标记** 则是为了修正并发标记期间因用户程序继续运行导致标记发生变动的对象（采用增量更新技术），这个过程暂停时间比初始标记长，但远不及并发标记花费的时间。最后的 **并发清除** 阶段清除掉被标记的对象，因为不需要移动存活对象，所以能和用户线程并发执行。

总体来说 CMS 垃圾收集耗时最长的并发标记和并发清除阶段都是和用户进行并发执行的。其命名已经体现出明显的几个优点：**并发收集、低延时**。这是 HotSpot 追求低延时的第一次成功，但是 CMS 远远达不到完美，至少有三个明显缺点：

- CMS 对处理器资源十分敏感。CMS 在并发阶段虽然不会停止用户线程，但是因为占用了一部分线程导致总吞吐量降低。CMS 默认启动的回收线程数是 ( 核心数量 +3 ) /4。如果核心数大于 4，并发回收时垃圾收集线程只占用 不超过 25% 的运算资源。但是如果核心数不足 4 个，CMS 对用户线程的影响就可能很大。比如用户线程本来的处理器负载已经很高，突然要分出一半左右的性能进行垃圾回收，用户线程执行速度就会突然大幅下降。

  曾经有过让垃圾回收线程和用户线程交替运行的增量式 CMS ( i-CMS )，但实践证明 i-CMS 效果很一般，从 JDK 7 开始已经弃用、到 JDK 9 发布后完全废弃。

- 由于 CMS 无法处理浮动垃圾（Floating Garbage），有可能出现并发失败从而进入一次完全停止用户线程的整堆垃圾回收。因为在 CMS 的并发阶段用户线程也在不断运行、同样会产生需要回收的对象，这些对象只能留到下次垃圾回收再清理，于是形成 **浮动垃圾**。而且用户线程执行期间不可避免地要分配内存，需要给用户线程预留内存在并发期间使用，因此 CMS 垃圾收集不能像其他垃圾收集器一样等老年代空间填满才启动回收。

  这就带来了 CMS 的又一个风险：不管给用户线程预留多大的内存都有可能出现 CMS 并发期间用户线程内存不足的情况（**并发失败，Concurrent Mode Failure**）。一旦出现并发失败虚拟机就不得不冻结用户线程，临时启用 Serial Old 重新执行一次老年代垃圾收集，这样暂停的时间就更长。这里 CMS 有 `-XX:CMSInitiatingOccupancyFraction` 参数来控制老年代空间使用率达到多大就启动 CMS 垃圾回收。

- CMS 采用的 **标记 - 清除** 算法会产生大量的内存碎片，一旦到最大连续可用内存不足的程度就必须启动一次 Full GC，这个过程中可能会要实施 **标记 - 整理** 算法消除内存碎片。

  因为在 Shenandoah 和 ZGC 出现之前，移动存活对象的过程无法实现并发，所以内存碎片整理的过程必须停止用户线程，这样又会导致暂停时间变长。CMS 可以通过 `-XX:UseCMSCompactAtFullCollection` 参数让虚拟机的每次 Full GC 都进行碎片整理，或者使用 `-XX:CMSFullGCsBeforeCompaction` 参数要求虚拟机进行一次整理碎片的 Full GC 之前必须经过若干次不整理碎片的 Full GC。这两个参数都从 JDK 9 开始废弃。

### Garbage First ( G1 ) 收集器

**[9 Garbage-First Garbage Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection)**

- [Allocation (Evacuation) Failure](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#allocation_evacuation_failure)
- [Floating Garbage](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#sthref47)
- [Pauses](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#pauses)
- [Card Tables and Concurrent Phases](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#sthref48)
- [Starting a Concurrent Collection Cycle](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#sthref49)
- [Pause Time Goal](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#pause_time_goal)

**[10 Garbage-First Garbage Collector Tuning](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#g1_gc_tuning)**

- [Garbage Collection Phases](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#sthref50)
- [Young Garbage Collections](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#sthref51)
- [Mixed Garbage Collections](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#sthref52)
- [Phases of the Marking Cycle](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#sthref53)
- [Important Defaults](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#important_defaults)
- [How to Unlock Experimental VM Flags](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#how_to_unlock_experimental_vm_flags)
- [Recommendations](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations)
- [Overflow and Exhausted Log Messages](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#sthref61)
- [Humongous Objects and Humongous Allocations](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#humongous)

G1 是一个里程碑式成果，开创了面向局部手机的设计思路和基于 Region 的内存布局。它是一款主要面向服务端的垃圾收集器，HotSpot 团队致力于使 G1 取代 CMS，这里涉及了从 JDK 7 开始确立项目目标，到 JDK 9 宣告 G1 取代 Parallel Scavenge+Parallel Old、弃用 CMS 的历史。

#### G1 的基本思想

为了继承和替代 CMS 的目标，设计者致力于建立暂停时间模型（Pause Prediction Model）的收集器，其含义是支持在 M 毫秒的时间段内消耗在垃圾收集上的时间大概率不超过 N 毫秒的目标，这几乎已经是实时 Java（RTSJ）中软实时垃圾收集器的特征了。

为了这个目标，G1 突破了单独面向新生代或老年代和整个 Java 堆的垃圾收集，把连续的 Java 堆划分成多个大小相等的 Region，每个 Region 都可以根据需要扮演 Eden、Survivor 或者老年代空间，形成基于 Region 的堆内存布局。可以通过参数 `-XX:G1HeapRegionSize` 设置 Region 大小为 1-32MB 且为 2 的整数幂大小。而垃圾收集范围可以由 任何 Region 组成 **回收集（CSet）**，回收哪个范围的标准不再是分代，而是哪些区域回收收益最大，这就是 G1 的 **Mixed GC 模式**。

G1 收集器还有一种特殊的 **Humongous 区域**，专门储存大对象。G1 认为只要超过 Region 容量的一半就是大对象，而超出整个 Region 容量的对象被放在连续的 Humongous Region 中，G1 的多数行为都把 H 区作为老年代看待。

在 G1 的 Region 内存布局之下，新生代和老年代成为一系列 Region 的动态集合。G1 把 Region 作为单词回收的最小单元，这样避免了有计划地对整个 Java 堆进行垃圾收集。G1 会维护各区域的“价值”大小：回收可获得的空间大小和回收时间的经验值，然后利用后台维护的优先级列表，根据用户设定的暂停时间优先收集回收价值最高的 Region。这也是 G1 名称的由来。

#### G1 回收流程

如果不计用户线程运行过程中的动作（比如使用写屏障维护记忆集），G1 回收流程可以分为四个步骤：

- **初始标记（Initial Marking）**：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。
- **并发标记（Concurrent Marking）**：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。
- **最终标记（Final Marking）**：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。
- **筛选回收（Live Data Counting and Evacuation）**：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

总体来说 G1 只在并发标记阶段是不暂停用户线程的。G1 并非纯粹地追求低延迟，其目标是在延迟可控的情况下尽可能得到高的吞吐量。用户可以指定希望的暂停时间是 G1 收集器的强大功能，从此最先进的垃圾收集器设计都转向追求能够应付应用内存分配速率，而不是一次把整个 Java 堆清理干净。只要垃圾收集速度能和对象分配速度相匹配，应用就可以很流畅的运行。

#### G1 与 CMS 的对比

CMS 是追求低延迟的收集器，G1 则是在延迟可控条件下追求更高的吞吐量。因为两者都是基本可以和用户并发执行，在 HotSpot 虚拟机垃圾回收调优指南中被并称为 **基本并发的收集器**（[Mostly Concurrent Collectors](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/concurrent.html#sthref33)）。

G1 相比 CMS 的优点有很多。CMS 可以认为是主要采用了 **标记 - 清除算法**，而 G1 则是从整体上看是 **标记 - 整理**，从局部来说是 **标记 - 复制**。这意味着 G1 不会产生内存碎片，有利于程序长时间运行、也有利于大对象居多的应用程序。G1 还有很多创新性设计：可以指定最大暂停时间、基于 Region 的堆内存布局、按回收价值确定回收集等。

G1 相对 CMS 并没有全方位的压倒性优势，G1 无论是垃圾收集中的内存占用（Footprint）还是程序运行时的额外执行负载都比 CMS 高。

从内存占用角度来说，CMS 和 G1 都用由 **卡表（Card Table）** 构成的 **记忆集（Remembered Set）** 处理跨代引用，但 G1 不仅卡表的实现更复杂而且每个 Region 都需要一份卡表，因此 G1 的记忆集（和其他内存消耗）可能会占整个堆容量的 20% 乃至更多的内存空间。

CMS 和 G1 都用到了写屏障，但 G1 除了使用写后屏障更新维护卡表，还需要使用写前屏障来实现 **原始快照搜索算法（SATB）**。相比 CMS 使用的增量更新算法，原始快照搜索能减少并发标记和重新标记阶段的消耗，避免 CMS 在最终标记阶段暂停时间长的缺点，但是用户程序运行过程中又有了跟踪引用变化的额外负担。CMS 写屏障的实现是同步操作，而 G1 的写屏障操作复杂、需要消耗更多计算资源，不得不把写屏障操作实现为类似消息队列的结构进行异步处理。

从实践经验来说 CMS 在小内存应用上表现大概率优于 G1，平衡点的 Java 堆容量通常在 6-8GB 之间。

## 低延迟垃圾收集器

// TODO《深入理解 Java 虚拟机》3.6 Page 154

### Shenandoah 收集器

### ZGC 收集器

## 垃圾收集器的选择

- [5 Available Collectors](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref27)

- [Selecting a Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28)

| Serial       | Parallel          | Mostly Concurrent | /       |
| ------------ | ----------------- | ----------------- | ------- |
| Serial       | ParNew            | CMS               | epsilon |
| Serial Old   | Parallel Scavenge | G1                |         |
| PS MarkSweep | Parallel Old      | Shenandoah        |         |
|              |                   | ZGC               |         |

### 垃圾收集器性能指标

- [Maximum Pause Time Goal](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref12)
- [Throughput Goal](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref13)
- [Footprint Goal](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref14)

#### 1. 暂停时间

暂停时间是垃圾收集器暂停运行的应用，回收不再使用的内存空间的过程。最大暂停时间的指标是为了限制垃圾收集过程所需的时间。垃圾收集器会维护平均暂停时间和相应的方差，平均时间从虚拟机启动就开始记录，但是越是最近的暂停时间权重越高。如果平均暂停时间和暂停时间的方差超出了规定的最大暂停时间，垃圾收集器就认为最大暂停时间这一目标没有得到满足。

最大暂停时间通过命令行参数 `-XX: MaxGCPauseMillis=<nnn>` 来指定，意味着垃圾收集器需要尽可能保证不超过 `<nnn>` 毫秒的暂停时间。垃圾收集器会通过调整 Java 堆大小或者其他相关参数来维护最大暂停时间目标。

默认情况下没有最大暂停时间的限制。调整最大暂停时间可能导致垃圾收集器频繁做出一些调整，从而降低应用的总体吞吐量。垃圾收集器总是会比吞吐量目标优先满足暂停时间的目标。尽管有些情况下暂停时间目标根本无法满足。

#### 2. 吞吐量

吞吐量是根据垃圾收集器花费的时间和垃圾收集器之外的执行时间来衡量的。吞吐量目标通过 `-XX: GCTimeRatio=<nnn>` 这个命令行参数来指定。垃圾收集器时间和应用时间之比是 `1/ (1 + <nnn>)`。例如，`-XX: GCTimeRatio=19` 设置垃圾收集器执行时间在总体执行时间中占比不超过 5%。

垃圾收集花费的时间包括新生代回收和老年待回收所占用的时间。如果吞吐量目标没有满足，为了增加应用执行时间，垃圾收集器会增加各代的大小。

#### 3. Footprint

如果吞吐量和最大暂停时间目标都被满足，垃圾收集器会把 Java 堆大小减小到吞吐量目标无法满足的程度，然后解决无法满足的目标。

堆大小会适时调整来支持所选的吞吐量目标，应用行为的改变可能导致堆的生长或收缩。例如，如果应用内存分配频率提高，堆空间就会生长来维持同等的吞吐量。

如果堆空间已经生长到最大值，而吞吐量目标还是无法满足，则说明最大堆大小的设置不足以支持设置的吞吐量目标。需要把堆大小设置到接近平台物理内存的大小又不会使得应用交换内存的程度，然后重新运行应用。如果仍然无法满足吞吐量目标，说明物理机器无法支撑相应的应用运行时间（吞吐量）。

如果满足了吞吐量目标，但是存在过长的暂停时间，就需要选择最大暂停时间目标。但是选择了最大暂停时间就意味着最大暂停时间无法满足，因此得根据应用在吞吐量和暂停时间之间做出折中。

通常垃圾回收器在尝试满足相互冲突的目标时，堆大小会出现震荡。即使应用已经达到稳定状态，也有可能出现这种情况。因为满足吞吐量要求更大的堆大小，而满足最大暂停时间和最小 footprint 都要求更小的堆大小。

## HotSpot 算法实现细节

// TODO《深入理解 Java 虚拟机》3.4. Page 122

### 根节点枚举：OopMap

### 安全点

### 安全区域

### 记忆集与卡表

### 写屏障

### 并发的可达性分析
