---
scope: learn
draft: true
---
# 虚拟机执行子系统

## 运行时数据区

Java 虚拟机定义了各种在程序执行过程中使用的运行时数据区。这其中有些数据结构是所有线程共享的，在 虚拟机启动时被创建的、只在虚拟机退出时被销毁。其他的数据结构则是线程私有的，在线程创建和退出时被创建和销毁。

### 1. 程序计数器

Java 虚拟机支持一次性运行很多线程，每个线程都有自己的程序计数器。在任何时刻，每个 Java 虚拟机线程都在执行一个方法的代码，也就是相应线程的当前方法。如果这个方法不是本地方法，则程序计数器包含 当前正在执行的虚拟机指令的地址。如果当前方法是本地方法，程序计数器的值是特定平台的本地指针。Java 虚拟机的程序计数器有足够的字宽容纳 返回地址或者特定平台的本地指针。

### 2. 栈

每个虚拟机线程都有一个私有的虚拟机栈，和线程同时被创建。Java 虚拟机栈保存栈帧。Java 虚拟机栈 和 *C* 语言之类的传统语言的栈是类似的：栈帧中保存局部变量和中间结果，在方法调用和返回中起作用。由于 Java 虚拟机除了压栈和弹栈之外不会直接操作栈帧，所以栈帧可以从堆分配。Java 虚拟机的栈内存不需要连续。

JVM 规范允许 Java 虚拟机栈采用固定大小或者根据计算的要求动态地扩容或收缩。如果 Java 虚拟机栈采用了固定大小，在栈创建时每个栈的大小可以独立地设置。

Java 虚拟机实现需要给编程人员或用户提供控制 Java 虚拟机栈初始大小的功能，或者在采用动态扩容的收缩的方式时，让用户能够控制最大和最小的栈大小。

以下几种异常与 Java 虚拟机栈有关：

- 如果某个线程中的操作请求了超出虚拟机允许的栈大小，虚拟机会报告 `StackOverflowError`

- 如果 Java 虚拟机栈可以动态扩容，并且尝试扩容时发现剩余堆内存不足以使扩容生效，或者是无法给新线程创建初始栈，那么 Java 虚拟机会报告 `OutOfMemoryError`

### 3. 堆

Java 虚拟机有一个所有线程共享的堆，堆是所有类对象和数组分配存储空间的运行时数据区。

堆在 虚拟机启动时创建。对象的堆存储由自动存储管理系统（垃圾回收器）回收，对象不需要显式地销毁。Java 虚拟机不假定有任何特定的自动存储管理系统，相应的存储管理技术根据实现者的系统要求选择。对也可以是固定大小或者可以动态扩容和收缩的。堆内存也不需要连续。

Java 虚拟机实现需要给编程人员或用户提供控制 初始堆大小的功能，或者在采用动态扩容的收缩的方式时，让用户能够控制最大和最小的堆大小。

以下的异常和堆相关：

- 如果自动存储管理系统无法提供一次操作所需的堆空间大小，Java 虚拟机会报告 `OutOfMemoryError`

### 4. 方法区

Java 虚拟机有一个所有线程共享的方法区。方法区类似于传统语言的编译代码的存储区，或者类似于操作系统进程中的“文本”段。  堆会保存一些类级的数据结构，例如运行时常量池、字段和方法数据、方法和构造函数的代码，包括类和对象初始化、接口初始化中使用的特殊方法。

方法区是在虚拟机启动时创建的。尽管方法区逻辑上是堆的一部分，但简单的实现一般既不会给方法区进行垃圾回收、也不会进行碎片整理。JVM 规范没有要求方法区的位置，也没有要求用来管理编译代码的策略。方法区可以是固定大小或者根据需要动态地扩容的收缩。方法区内存也不需要连续。

Java 虚拟机实现应该给用户提供控制初始方法区大小的功能，或者在采用动态方法区的情况下，让用户能够控制最大和最小的方法区大小。

下面的异常和方法区相关：

- 如果方法区内存大小无法满足分配请求，Java 虚拟机会报告 `OutOfMemoryError`

### 5. 运行时常量池

运行时常量池是类文件中 `constant_pool` 表的类级或接口级表示。运行时常量池包含从编译期就识别到的数值字面量，到必须在运行阶段解析的方法和字段引用的各种常量。运行时常量池发挥着和传统语言中符号表类似的功能，尽管它包含比符号表更广泛的数据。

每个运行时常量池都是从 Java 虚拟机的方法区分配空间，运行时常量池在虚拟机创建类或接口时被构造。

以下异常和类或接口的运行时常量池构造有关：

- 在创建类或接口时，如果构造运行时常量池要求的内存超出了虚拟机方法区剩余内存，会报告 `OutOfMemoryError`

### 6. 本地方法栈

Java 虚拟机使用传统栈（通俗地叫做 C 语言栈）来支持本地方法（用非 Java 的其它语言编写的方法）。本地方法栈也可以被 Java 虚拟机解释器的 C 语言实现使用。无法加载本地方法的 Java 虚拟机实现和本身不需要依赖传统栈的虚拟机实现则不必提供本地方法栈。如果提供了本地方法栈，通常每个线程创建时都会分配一个本地方法栈。

JVM 规范允许本地方法栈采用固定大小或者可以根据需要扩容和收缩的动态方式。如果本地方法栈是固定大小，每个本地方法栈创建时都可以独立地设置其大小。

Java 虚拟机实现应该给用户提供控制本地方法栈初始大小的功能，或者在本地方法栈采用动态大小时，让用户控制本地方法栈的最大和最小的大小。

以下异常和本地方法栈相关：

- `StackOverflowError`

- `OutOfMemoryError`

### 7. 直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 `OutOfMemoryError` 异常出现，所以我们放到这里一起讲解。

在JDK 1.4中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 `DirectByteBuffer` 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、 SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 `-Xmx` 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 `OutOfMemoryError` 异常。

## 运行时栈帧结构

栈帧用来保存方法执行过程中的数据和中间结果，以及执行动态链接、保存方法返回值、分派异常。

每次调用方法时会创建新的栈帧。不管方法调用是否正常完成还是由于抛出未捕获的异常而中断，只要方法调用完成就会销毁栈帧。栈帧是从调用方法的线程中的虚拟机栈中分配空间。每个栈帧都保存了自己的局部变量数组、操作数栈和对当前线程所运行类的运行时常量池的引用（动态链接）。栈帧还可以保存一些与实现有关的额外信息，例如调试信息。

《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。在讨论概念时，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。

参考 《深入理解 Java 虚拟机》 8.2 运行时栈帧结构 Page 400，运行时栈帧结构总结如下：

- 局部变量表

- 操作数栈

- 动态链接

- 方法返回地址

- 附加信息

局部变量数组的大小和操作数栈的大小在编译期确定，和栈帧相应的方法代码一同提供。因此栈帧数据结构的大小只取决于 Java 虚拟机的实现，以及在方法调用时能为这些数据结构分配的内存大小。

在给定主控线程的任何执行点只有一个当前执行方法对应的栈帧是活跃的，这个栈帧叫做**当前栈帧**，对应的方法叫做当前方法。定义了当前方法的类叫做当前类。对局部变量和操作数栈的操作都是针对当前栈帧进行的。

如果当前方法调用了另一个方法或者这个方法调用完成，相应的栈帧就不再是当前栈帧。在方法被调用时，创建一个新栈帧，这个栈帧在主控线程的执行切换到这个新方法时成为当前栈帧。在方法返回时当前栈帧把方法调用的结果传递给前一个栈帧。然后当前栈帧被销毁，前一个栈帧成为当前栈帧。

要注意某个线程创建的栈帧只属于该线程本地，无法被其他任何线程引用。

### 0. 虚拟机字节码执行引擎

《Java 虚拟机规范》指定了 Java 虚拟机字节码执行引擎的概念模型，这成为各种 Java 虚拟机执行引擎的统一外观（ Facade ）。在不同的虚拟机实现中，执行引擎在执行字节码时，通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，还有可能同时包含几个不同级别的即时编译器一起工作。但从外观上看，所有 Java 虚拟机的执行引擎输入输出都是一致的：输入的是二进制的字节码，处理过程是字节码解析执行的等效过程，输出的是执行结果。

> 有一些虚拟机（如Sun Classic VM）的内部只存在解释器，只能解释执行，另外一些虚拟机（如BEA JRockit）的内部只存在即时编译器，只能编译执行。

### 1. 局部变量

每个栈帧都保存了局部变量数组。局部变量数组的长度在编译期确定，和当前栈帧相应的方法代码一起在类或接口的二进制表示中提供。

单个局部变量可以保存 `boolean`、`byte`、`char` 、`short`、`int`、`float`、`reference` 或者 `returnAddress` 类型的值。一对局部变量可以保存 `long` 或者 `double` 类型的值。

局部变量通过索引来寻址。第一个局部变量的索引是 0 。当且仅当一个整数数值的大小处于 0 到 局部变量数组的大小减一范围内，这个整数才被认为是局部变量的索引。

`long` 或 `double` 类型的局部变量占用两个连续的局部变量空间。这样的值只能通过较小的索引值来寻址。例如，在局部变量数组中偏移量为 *n* 的位置保存的一个 `double` 类型的局部变量，实际上占用了 *n* 和 *n + 1* 所对应的两个存储空间。但是处于 *n + 1* 位置的变量不能被访问。

Java 虚拟机不要求索引 *n* 是偶数，直观地说，`long` 或者 `double` 类型的值在局部变量数组中不需要进行 64 比特对齐。实现者对于这样的值可以使用两个局部变量存储空间自由选择合适的表示方式。

Java 虚拟机使用局部变量在方法调用时传递参数。在调用类方法时，所有参数都从索引 0 开始以连续的局部变量方式传递。在调用实例方法时，索引 0 位置的局部变量则用来传递目标方法所绑定的对象引用。剩余的所有参数通过局部变量数组中从索引 1 开始的局部变量传递。

### 2. 操作数栈

操作数栈是栈帧中的一个 LIFO 栈。操作数栈的最大深度在编译期确定，随栈帧对应的方法代码一同提供。

在新的栈帧被创建时，操作数栈为空。Java 虚拟机提供了从局部变量或字段载入变量到操作数栈的指令。还有一些 Java 虚拟机指令从操作数栈中获取操作数，进行某种计算、然后把计算结果存入操作数栈。操作数栈也被用来准备方法调用所需的参数，以及接收方法调用结果。

例如 `iadd` 指令把两个 `int` 值相加，这个指令要求想家的两个操作数处于操作数栈的栈顶（被前面的指令存入栈顶）。之后两个 `int` 值都从栈顶被弹出、相加，然后把他们相加的结果存入栈顶。在操作数栈上可以进行嵌套表达使得计算，产生嵌套计算的结果。

操作数栈中的每个条目都可以保存任意的 Java 虚拟机类型，包括 `long` 和 `double` 类型。操作数栈中的数值必须使用适合其类型的指令进行操作。例如，不能把两个 `int` 值压栈后续却把他们当做 `long` 值计算，或者把两个 `float` 值压栈后用 `iadd` 指令把它们相加。有一小部分 Java 虚拟机指令 （`dup` 和 `swap`） 把运行时数据区的变量当做无关特定类型的原始值进行处理，这些指令不能修改或分解单个值。这些操作操作数栈的限制是通过验证类文件来保证的。

关于操作数栈的深度，`long` 和 `double` 类型占用两个单位的深度，而其他类型所占用的深度都是 1 。

### 3. 动态链接

每个栈帧中都包含一个指向运行时常量池中当前方法类型的引用，这个引用是为了支持方法代码中的 *动态链接*。方法所处的类文件代码中引用了将要调用的方法和将要访问的变量的符号引用。动态链接把这些方法的符号链接转化为方法的直接引用，在需要解析还未定义的符号链接时加载相应的嘞，把通过符号链接访问的变量转化为与这些变量 运行时位置相关的存储结构中的偏移量。

这种方法和变量的延迟绑定降低了被引用类中的改变破坏当前类文件代码的可能。

### 4.方法返回地址

**方法调用正常完成**

如果方法调用没有导致 Java 虚拟机直接抛出异常，后者导致 显式的 *throw* 语句执行而抛出异常，则这个方法调用就是正常完成。如果当前方法调用正常完成，就会给调用方（主调方法）返回计算结果。调用结果的返回发生在被调用方法执行某一种返回指令时，返回指令的选择也必须与将要返回的值的类型相匹配。

**方法调用异常完成**

如果方法中 Java 虚拟机指令的执行导致虚拟机抛出了异常，并且这个异常在方法中没有被处理，该方法调用就是异常完成。执行 `athrow` 指令也会导致显式的抛出异常，如果这个异常没有被当前方法捕获，就会使得方法调用异常完成。异常完成的方法调用不会给调用方返回结果。

无论方法调用以哪种方式完成，都必须返回主调方法执行的位置。方法返回时需要在相应栈帧中保存一些信息，来帮助恢复主调方法的执行状态。一般来说，方法正常退出时，主调方法中程序计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器。而方法异常退出时，返回地址则是通过异常处理器表来确定，栈帧一般不会保存这些信息。

方法调用完成之后，当前栈帧出栈，恢复主调方法的局部变量表和操作数栈。虚拟机执行引擎利用主调方法合理维护的程序计数器，将其自增之后跳过方法调用语句，指向主调方法中下一条指令。如果被调方法有返回值的话把方法调用返回的结果压入操作数栈顶部，继续执行主调方法。


## 方法调用

// TODO 参考 《深入理解 Java 虚拟机》 8.3 方法调用 Page 412

方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作之一，但第 7 章中已经讲过，Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局

中的入口地址（也就是之前说的直接引用）。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

- 解析
- 分派
  - 静态分派
  - 动态分派
  - 单分派与多分派
  - 虚拟机动态分派的实现


# HotSpot 虚拟机的对象布局

// TODO 参考《深入理解 Java 虚拟机》 2.3 HotSpot 虚拟机对象揭秘 Page 84

[Java String](Java%20String.md)