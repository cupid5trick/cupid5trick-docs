Java 类加载器和双亲委派机制
类加载器可以说是 Java 语言的一项创新，它是早期 Java 语言能够快速流行的重要原因之一。类加载器最
初是为了满足 Java Applet 的需求而设计出来的，在今天用在浏览器上的 Java Applet 技术基本上已经被淘
汰，但类加载器却在类层次划分、OSGi、程序热部署、代码加密等领域大放异彩，成为 Java 技术体系中一块重
要的基石，可谓是失之桑榆，收之东隅。

类与类加载器
类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远超类加载阶段。对于任意一个
类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都
拥有一个独立的类名称空间。即使两个类来自同一个 类文件，被同一个 Java 虚拟机加载，只要其类加载器不
同，这两个类就必定不相等。
这里的类相等关系包括代表类的 Class 对象的 equals 、 isAssignableFrom 、 isInstance 方法的返回
值，也包括了 instanceof 运算符判断对象和类所属关系等情况。如果没有注意到类加载器的影响，某些情况
下就有可能产生迷惑性的结果。

双亲委派机制
从 Java 虚拟机的角度看，只存在两种类加载器：引导类加载器（使用 C 语言实现，属于虚拟机自身的一部
分）和其他所有类加载器。其他类加载器都是用 Java 语言实现，存在于虚拟机之外，并且全部继承自抽象类
java.lang.ClassLoader 。

而站在 Java 开发人员的角度，类加载器 从 JDK 1.2 以来一直保持相对稳定的三层类加载器、双亲委派的类
加载架构。在 JDK 8 及以前的 Java 应用中绝大多数 Java 程序都使用以下 3 个系统提供的类加载器来加载类。
引导类加载器（ Bootstrap Class Loader ）：负责加载存放在 <JAVA_HOME>/lib 目录、或者被 Xbootclasspath 参数所指定的目录下，并且能被 Java 虚拟机通过文件名识别的类（例如
rt.jar 、 tools.jar ，文件名不符合的类即使被放入 lib 目录也不会被夹在）。引导类加载器无法

被 Java 程序直接引用，用户编写自定义类加载器时，如果需要把类加载请求委派给引导类加载器，直
接使用 null 即可。
扩展类加载器（ Extension Class Loader ）：这个类加载器在
sun.misc.Launcher$ExtClassLoader 中以 Java 代码实现。扩展类加载器负责加载
<JAVA_HOME>/lib/ext 目录中、或者被 java.ext.dirs 系统变量所指定的目录中的所有类库。

JDK 开发团队允许用户将具有通用性的类库放在 ext 目录下来拓展 Java SE 的功能。由于扩展类加
载器是 Java 实现，开发者可以直接在程序中使用扩展类加载器加载类文件。
应用类加载器（ Application Class Loader ）：由 sun.misc.Launcher$AppClassLoader 实现。由
于应用类加载器是 ClassLoader 类 getSystemClassLoader 方法的返回值，所以也被叫做系统类
加载器。负责加载用户 ClassPath 上的所有类库，开发者同样可以直接在代码中使用应用类加载器。
如果程序中没有定义自己的类加载器，一般就作为默认的类加载器。

No. 1 / 3

JDK 9 之前的类加载都是通过以上三类类加载器相互配合实现的，被称为双亲委派机制。如果用户觉得有必
要可以定义自己的类加载器来进行扩展，典型的包括增加磁盘位置之外的类文件来源，或者通过类加载器实现类
的隔离、重载等功能。以下是三层类加载器双亲委派机制的示意图：

Boostrap ClassLoader

Extention ClassLoader

Application ClassLoader

User Defined ClassLoader2

User Defined ClassLoader2

双亲委派要求除顶层的引导类加载器之外，其他所有类加载器都应该有自己的父加载器。但这里的父子关系
并不以继承来体现，而通常是使用组合关系（ Composition ）来复用父加载器的代码。需要强调 双亲委派机制
从 JDK 1.2 引入之后广泛应用于几乎所有 Java 程序中，但并不是一个有强制约束力的模型，仅仅是 建议开发者
采用的一种类加载器的最佳实现。
双亲委派要求除顶层的引导类加载器之外，其他所有类加载器都应该有自己的父加载器。但这里的父子关系
并不以继承来体现，而通常是使用组合关系（ Composition ）来复用父加载器的代码。需要强调 双亲委派机制
从 JDK 1.2 引入之后广泛应用于几乎所有 Java 程序中，但并不是一个有强制约束力的模型，仅仅是 建议开发者
采用的一种类加载器的最佳实现。
双亲委派的工作流程是：类加载器收到类加载请求时，首先把类加载请求委派给父级类加载器处理，父级类
加载器同样遵守这个规则。最终所有类加载请求都会到达引导类加载器，只有在父级类加载器反馈自己无法完成
类加载请求时（父级加载器搜索范围内找不到相应的类），子类加载器才会自己尝试加载相应的类。
双亲委派机制带来的好处是 Java 类随着相应的类加载器一起具有了带有优先级的层次关系。例如类
java.lang.Object ，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型

最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都能够保证是同一个类。反
之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为
java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类，Java 类

型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。
如果写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现它可以正常编译，但永远无法被加载运行。
即使定义了自己的类加载器，强行使用 defineClass 方法加载一个以 java.lang 开头的类也无法成功，将会
出现 Java 虚拟机内部抛出的 java.lang.SecurityException Prohibited package name: java.lang 异
常。

No. 2 / 3

需要注意引导类加载器只有在 HotSpot 虚拟机中才是 C++ 实现的。像 MRP、Maxine 这些完全由 Java
实现的虚拟机，引导类加载器就是 Java 语言实现。退一步说，除 HotSpot 之外 JRockit 和 J9 两个高性能虚拟
机都有一个 代表 Bootstrap ClassLoader 的 Java 类存在，但是关键方法的实现依然是使用 Java 本地方法
（JNI）回调到 C 语言的实现，这个引导类加载器也无法被用户获取到。JDK 9 之后，HotSpot 也采用了虚拟机
和 Java 类相互配合实现引导类加载器的方式，所以 JDK 9 之后也有了一个代表引导类加载器却无法获取到示例
的 Java 类存在。

突破双亲委派机制

No. 3 / 3

