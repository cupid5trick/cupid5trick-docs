---
title: 后端编译与优化
author: cupid5trick
created: 2023-04-07 19:00
tags: 
categories: 
access: private
draft: true
lang:
- zh-cn
- en-us
abstract:
keywords:
---


# 即时编译

主流的商用 Java 虚拟机，譬如 HotSpot、OpenJ9 等，内部都同时包含解释器与编译器。

解释器与编译器两者各有优势： 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的 JavaCard 应用中就只有解释器的存在），反之可以使用编译执行来提升效率。

同时，解释器还可以作为编译器激进优化时后备的“逃生门”（如果情况允许， HotSpot 虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行。因此在整个 Java 虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作。

在分层编译（Tiered Compilation）的工作模式出现以前，HotSpot 虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作，程序使用哪个编译器，只取决于虚拟机运行的模式，HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在客户端模式还是服务端模式。

无论采用的编译器是客户端编译器还是服务端编译器，解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”（Mixed Mode），用户也可以使用参数“-Xint”强制虚拟机运行于“解释模式”（Interpreted Mode），这时候编译器完全不介入工作，全部代码都使用解释方式执行。另外，也可以使用参数“-Xcomp”强制虚拟机运行于“编译模式”（Compiled Mode），这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。

## 分层编译

由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot 虚拟机在编译子系统中加入了分层编译的功能。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：

- Level 0：程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。
- Level 1：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。
- Level 2：仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。
- Level 3：仍然使用客户端编译器执行，开启全部性能监控，除了第 2 层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。
- Level 4：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。

实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量，在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间。

## 热点代码

**关于热点代码**

程序运行过程中，虚拟机对热点代码进行即时编译。这里的热点代码主要包括两类：
- 多次调用的方法
- 多次执行的循环体

后者针对的是方法体内循环次数较大的循环体。两种情况都是对整个方法体进行即时编译，区别在于方法体作为热点代码，执行入口就是方法体的第一条字节码，而当热点代码是循环体时，方法体已经处于调用过程中，被加载到栈内存中，执行的入口地址有所不同。编译器仍然以整个方法体作为编译对象，仅仅传入的执行入口点字节码序号（Byte Code Index， BCI）有所不同。即时编译完成后，该热点循环体代码就变成编译好的本地代码，因此也把这种即时编译叫做“栈上替换”（On Stack Replacement）。

**定位热点代码**

以方法体为单位，确定一段代码是不是热点代码，自然需要一个明确的阈值作为标准，这个过程称为“热点探测”。目前主流的热点探测方法有两种：
- 基于采样的热点探测：虚拟机周期性检查线程的方法栈栈顶，如果某些方法经常出现在栈顶，这个方法就是热点方法。采样方法的好处是简单高效，缺点是不够准确，容易受到线程阻塞或其他外界因素的干扰。
- 基于计数器的热点探测：虚拟机给每个方法甚至代码块建立计数器，统计执行次数。如果执行次数超过一定的阈值就判定为热点代码。这种统计方法占用更多内存，但是统计结果更准确。

HotSpot 虚拟机采用计数器实现热点探测。HotSpot 给每个方法都维护方法调用计数器和回边计数器（Back Edge Counter，“回边”指的是循环指针越过边界后往回跳转）。

## **方法调用计数器**

方法调用计数器统计方法的调用次数。HotSpot 的客户端模式下阈值是 1500，服务器模式下阈值是 10000，可以通过虚拟机参数 `-XX;CompileThreshold` 来设置。

当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成。（用户可以通过参数 `-XX:-BackgroudCompilation` 禁用后台编译，执行线程会阻塞到即时编译完成）当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值，下一次调用该方法时就会使用已编译的版本了。

方法计数器通常并不是统计方法确切的调用次数，在一定的时间内如果方法调用次数仍不足以触发即时编译，方法调用计数器就会减半。因此方法计数器可以看做是方法在一个周期内被调用的次数度量，这个周期被 HotSpot 叫做方法计数器的半衰周期（Counter Half Life Time），计数器减半的过程叫做热度衰减（Counter Decay）。方法计数器的半衰周期可以通过虚拟机参数 `-XX:CounterHalfTime` 设置。热度衰减是虚拟机垃圾收集时顺便完成的，可以通过虚拟机参数 ` -XX:-UseCounterDecay ` 关闭热度衰减：这样一来，只要程序运行时间足够长，绝大部分方法都会被编译成本地代码！

// TODO
*如果机器内存不足以容纳编译出的本地代码，并且已经无法通过垃圾收集回收到足够的内存，是否会发生 OOM，还是删除一些本地代码？*

## **回边计数器**

回边计数器是方法中循环体执行次数的度量，在字节码中遇到控制流向后跳转的指令就称为“回边”。回边计数器达到阈值就会触发“栈上替换”的即时编译。

HotSpot 虚拟机也提供了一个类似于方法调用计数器阈值 `-XX:CompileThreshold` 的参数 `-XX:BackEdgeThreshold` 供用户设置，但是当前的 HotSpot 虚拟机实际上并未使用此参数，我们必须设置另外一个参数 `-XX:OnStackReplacePercentage` 来间接调整回边计数器的阈值，其计算公式有如下两种。

- 客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（ `-XX:CompileThreshold` ）乘以 OSR 比率（ `-XX:OnStackReplacePercentage` ）除以 100。其中 `-XX:OnStackReplacePercentage` 默认值为 933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为 13995。 
- 服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（ `-XX:CompileThreshold` ）乘以 OSR 比率（ `-XX:OnStackReplacePercentage` ）减去解释器监控比率（ `-XX:InterpreterProfilePercentage` ）的差值）除以 100。其中 `-XX:OnStackReplacePercentage` 默认值为 140， `-XX:InterpreterProfilePercentage` 默认值为 33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为 10700。
- 
当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待即时编译完成就可以进行栈上替换了。

与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。**回边计数器溢出时，虚拟机还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程**。

## C1 即时编译过程

服务端编译器和客户端编译器的编译过程是有所差别的。对于客户端编译器来说，它是一个相对简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。

在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representation，HIR，即与目标机器指令集无关的中间表示）。HIR 使用静态单分配 （Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在 HIR 的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成 HIR 之前完成。

在第二个阶段，一个平台相关的后端从 HIR 中产生低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示），而在此之前会在 HIR 上完成另外一些优化，如空值检查消除、范围检查消除等，以便让 HIR 达到更高效的代码表示形式。

最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在 LIR 上分配寄存器，并在 LIR 上做窥孔（Peephole）优化，然后产生机器代码。

## C2 即时编译过程

服务端编译器则是专门面向服务端的典型应用场景，并为服务端的性能配置针对性调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器，几乎能达到 GNU C++编译器使用-O2 参数时的优化强度。它会执行大部分经典的优化动作，如：无用代码消除（Dead Code Elimination）、循环展开 （Loop Unrolling）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、常量传播（Constant Propagation）、基本块重排序（Basic Block Reordering）等，还会实施一些与 Java 语言特性密切相关的优化技术，如范围检查消除（Range Check Elimination）、空值检查消除（Null Check Elimination，不过并非所有的空值检查消除都是依赖编译器优化的，有一些是代码运行过程中自动优化了）等。另外，还可能根据解释器或客户端编译器提供的性能监控信息，进行一些不稳定的预测性激进优化，如守护内联（Guarded Inlining）、分支频率预测 （Branch Frequency Prediction）等。

服务端编译采用的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构（如 RISC）上的大寄存器集合。以即时编译的标准来看，服务端编译器无疑是比较缓慢的，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于客户端编译器编译输出的代码质量有很大提高，可以大幅减少本地代码的执行时间，从而抵消掉额外的编译时间开销，所以也有很多非服务端的应用选择使用服务端模式的 HotSpot 虚拟机来运行。

# 编译器优化技术

# 提前编译

# 关于 GraalVM


# 实践案例

## 查看分析即时编译

// TODO 参考《深入理解 Java 虚拟机》第四部分程序编译与代码优化 11.2.4 page 536
