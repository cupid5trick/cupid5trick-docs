---
scope: learn
draft: true
---


[Java Class文件格式详解 - 腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1816694): https://cloud.tencent.com/developer/article/1816694



// TODO 周志明《深入理解 Java 虚拟机》 6 类文件结构 Page 293

```C
`ClassFile` {
    u4             magic; //Class 文件的标志, 0xCAFEBABE
    u2             minor_version;//Class 的次版本号
    u2             major_version;//Class 的主版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    `field_info`     fields[fields_count];//一个类会可以有个字段
    u2             methods_count;//Class 文件的方法数量
    `method_info`    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

大端序和小端序：
大端序（Big-Endian），具体顺序是指按高位字节在地址最低位，最低字节在地址最高位来存储数据，它是 SPARC、PowerPC 等处理器的默认多字节存储顺序，而 x86 等处理器则是使用了相反的小端序（Little-Endian）顺序来存储数据。
## 常量池 `cp_info`
在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为 0 来表示。Class 文件结构中只有常量池的容量计数是从 1 开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从 0 开始。

常量池中主要存放两大类常量： **字面量（Literal） 和符号引用（Symbolic References）** 。

　　字面量比较接近于 Java 语言层面的常量概念，如文本字符串、被声明为 final 的常量值等。

　　符号引用则属于编译原理方面的概念，主要包括下面几类常量：

1.  被模块导出或者开放的包（Package）
2.  类和接口的全限定名（Fully Qualified Name）
3.  字段的名称和描述符（Descriptor）
4.  方法的名称和描述符
5.  方法句柄和方法类型（Method Handle、 Method Type、 Invoke Dynamic）
6.  动态调用点和动态常量（Dynamically-Computed Call Site、 Dynamically-Computed Constant）

虚拟机在加载 Class 文件时才会进行动态连接，也就是说，Class 文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的，当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

**符号引用**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。  
**直接引用**：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

常量池中每一项常量都是一个表，截至 JDK13，常量表中分别有 17 种不同类型的常量。这 17 类表都有一个共同的特点，表结构起始的第一位是个 u1 类型的标志位，代表着当前常量属于哪种常量类型。


| 类型 | 标志 | 描述 |
| --- | --- | --- |
| CONSTANT_Utf8_info | 1 | UTF-8 编码的字符串 |
| CONSTANT_Integer_info | 3 | 整形字面量，boolean、byte、char、short 等类型都用 int 存放 |
| CONSTANT_Float_info | 4 | 浮点型字面量 |
| CONSTANT_Long_info | 5 | 长整型字面量 |
| CONSTANT_Double_info | 6 | 双精度浮点型字面量 |
| CONSTANT_Class_info | 7 | 类或接口的符号引用 |
| CONSTANT_String_info | 8 | 字符串类型字面量 |
| CONSTANT_Fieldref_info | 9 | 字段的符号引用 |
| CONSTANT_Methodref_info | 10 | 类中方法的符号引用 |
| CONSTANT_InterfaceMethodref | 11 | 接口中方法的符号引用 |
| CONSTANT_NameAndType_info | 12 | 字段或方法的部分符号引用 |
| CONSTANT_MethodHandle_info | 15 | 方法句柄 |
| CONSTANT_MethodType_info | 16 | 方法类型 |
| CONSTANT_Dynamic_info | 17 | 表示一个动态计算常量 |
| CONSTANT_InvokeDynamic_info | 18 | 动态方法调用点 |
| CONSTANT_Module_info | 19 | 表示一个模块 |
| CONSTANT_Package_info | 20 | 表示一个模块开放或导出的包 |

### `CONSTANT_Utf8_info`

```c
CONSTANT_Utf8_info {
    u1 tag;                 // tag = 1
    u2 length;              // UTF8 编码字符串所占用的字节数
    u1 bytes[length];       // 包含字符串编码的字节数组
}
```

Length 值说明了这个 UTF-8 编码的字符串长度是多少字节，它后面紧跟着的长度为 length 字节的连续数据是一个使用 UTF-8 缩略编码表示的字符串。UTF-8 缩略编码与普通 UTF-8 编码的区别是： 从'\u0001'到'\u007f'之间的字符（相当于 1～127 的 ASCII 码）的缩略编码使用一个字节表示，从'\u0080'到'\u07ff'之间的所有字符的缩略编码用两个字节表示，从'\u0800'开始到'\uffff'之间的所有字符的缩略编码就按照普通 UTF-8 编码规则使用三个字节表示。

顺便提一下，由于 Class 文件中方法、字段等都需要引用 CONSTANT_Utf8_info 型常量来描述名称，所以 CONSTANT_Utf8_info 型常量的最大长度也就是 Java 中方法、字段名的最大长度。而这里的最大长度就是 length 的最大值，既 u2 类型能表达的最大值 65535。所以 Java 程序中如果定义了超过 64KB 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。

### `CONSTANT_Integer_info`

```c
CONSTANT_Integer_info {
    u1 tag;                 // tag = 3
    u4 bytes;
}
```

### `CONSTANT_Float_info`

```c
CONSTANT_Float_info {
    u1 tag;                 // tag = 4
    u4 bytes;
}
```

### `CONSTANT_Long_info`

```c
CONSTANT_Long_info {
    u1 tag;                 // tag = 5
    u4 high_bytes;
    u4 low_bytes;
}
```

### `CONSTANT_Double_info`

```c
CONSTANT_Double_info {
    u1 tag;                 // tag = 6
    u4 high_bytes;
    u4 low_bytes;
}
```

### `CONSTANT_Class_info`

代表了这个类（或者接口）的全限定名
```c
CONSTANT_Class_info {
    u1 tag;                 // tag = 7
    u2 name_index;          // 指向全限定类名 UTF8 字符串常量在常量池中的索引
}
```

### `CONSTANT_String_info`

```c
CONSTANT_String_info {
    u1 tag;                 // tag = 8
    u2 string_index;
}
```

### `CONSTANT_Fieldref_info`

```c
CONSTANT_Fieldref_info {
    u1 tag;                 // tag = 9
    u2 class_index;
    u2 name_and_type_index;
}
```

### `CONSTANT_Methodref_info`

```c
CONSTANT_Methodref_info {
    u1 tag;                 // tag = 10
    u2 class_index;
    u2 name_and_type_index;
}
```

### `CONSTANT_InterfaceMethodref_info`

```c
CONSTANT_InterfaceMethodref_info {
    u1 tag;                 // tag = 11
    u2 class_index;
    u2 name_and_type_index;
}
```

### `CONSTANT_NameAndType_info`

```c
CONSTANT_NameAndType_info {
    u1 tag;                 // tag = 12
    u2 name_index;
    u2 descriptor_index;
}
```

### `CONSTANT_MethodHandle_info`

```c
CONSTANT_MethodHandle_info {
    u1 tag;                 // tag = 15
    u1 reference_kind;
    u2 reference_index;
}
```

### `CONSTANT_MethodType_info`

```c
CONSTANT_MethodType_info {
    u1 tag;                 // tag = 16
    u2 descriptor_index;
}
```

### `CONSTANT_Dynamic_info`

```c

```

### `CONSTANT_InvokeDynamic_info`

```c
CONSTANT_InvokeDynamic_info {
    u1 tag;                 // tag = 18
    u2 bootstrap_method_attr_index;
    u2 name_and_type_index;
}
```

### `CONSTANT_Module_info`

```c

```

### `CONSTANT_Package_info`

```c

```


## 访问标志 `ACC_FLAGS`


| 标志名称       | 标志值 | 含义                                                                     |
| -------------- | ------ | ------------------------------------------------------------------------ |
| `ACC_PUBLIC`     | `0x0001` | 是否为 public 类型                                                       |
| `ACC_PRIVATE`    | `0x0002` | private, 访问仅限类内部                                                  |
| `ACC_PROTECTED`  | `0x0004` | protected, 类内和子类中可访问。                                          |
| `ACC_STATIC`     | `0x0008` | static, 静态字段或静态方法。                                             |
| `ACC_FINAL`      | `0x0010` | 是否被声明为 final，只有类可以设置                                       |
| `ACC_SUPER`      | `0x0020` | JDK 1.0.2 以后这个标志都为真                                              |
| `ACC_VOLATILE`   | `0x0040` | volatile，直接读写内存，不可被缓存。不可和 `ACC_FINAL` 一起使用。            |
| `ACC_TRANSIENT`  | `0x0080` | transient，在序列化中被忽略的字段。                                      |
| `ACC_INTERFACE`  | `0x0200` | 标识这是一个接口                                                         |
| `ACC_ABSTRACT`   | `0x0400` | 是否为 abstract 类型，对于接口或抽象类来说，此标志值为真，其他类值为假。 | 
| `ACC_SYNTHETIC`  | `0x1000` | 标识这个类并非由用户代码产生,由编译器产生，不存在于源代码中。            |
| `ACC_ANNOTATION` | `0x2000` | 标识这是一个注解。                                                       |
| `ACC_ENUM`       | `0x4000` | 标识这是一个枚举。                                                       |
| `ACC_MODULE`     | `0x8000` | 标识这是一个模块。                                                       |

## 类索引、父类索引与接口索引集合

类索引（this_class）和父类索引（super_class）都是一个 u2 类型的数据，而接口索引集合 （interfaces）是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定该类型的继承关系。

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 `java.lang.Object` 之外，所有的 Java 类都有父类，因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为 0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 关键字（如果这个 Class 文件表示的是一个接口，则应当是 extends 关键字）后的接口顺序从左到右排列在接口索引集合中。

## 字段表

字段表的结构定义如下：

```c
`field_info` {
    u2              access_flags;
    u2              name_index;
    u2              descriptor_index;
    u2              attributes_count;
    attribute_info  attributes[attributes_count];
}
```

字段表（`field_info`） 用于描述接口或者类中声明的变量。 Java 语言中的“字段”（Field） 包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段可以包括的修饰符有字段的作用域（public、 private、 protected 修饰符） 、是实例变量还是类变量（static 修饰符） 、可变性（final） 、并发可见性（volatile 修饰符，是否强制从主内存读写） 、可否被序列化（transient 修饰符） 、字段数据类型（基本类型、对象、数组） 、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

`name_index` 和 `descriptor_index` ，它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。现在需要解释一下“简单名称”“描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念。

**全限定名、简单名称和方法、字段描述符**

**全限定名**和**简单名称**很好理解，。例如 `org/fenixsoft/clazz/TestClass` 是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”号表示全限定名结束。简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的 inc () 方法和 m 字段的简单名称分别就是“inc”和“m”。

相比于全限定名和简单名称，方法和字段的**描述符**就要复杂一些。描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示。下面列出描述符标识字符的含义。

参考 JVM 标准文档 4.3.2 Field Descriptors 和 4.3.3 Method Descriptors。

| 标识字符 | 含义                                           |
| -------- | ---------------------------------------------- |
| `B`      | 基本类型 byte                                  |
| `C`      | 基本类型 char                                  |
| `D`      | 基本类型 double                                |
| `F`      | 基本类型 float                                 |
| `I`      | 基本类型 int                                   |
| `J`      | 基本类型 long                                  |
| `S`      | 基本类型 short                                 |
| `Z`      | 基本类型 boolean                               |
| `V`      | 特殊类型 void                                  |
| `L`      | 用来表示一个引用类型。例如：`java/lang/Object` |
| `[`      | 用来表示数组类型。例如： `[java/lang/Integer`  | 

注：void 类型在《Java 虚拟机规范》之中单独列出为“ `VoidDescriptor` ”，笔者为了结构统一，将其列在基本数据类型中一起描述。

对于数组类型，每一维度将使用一个前置的`[`字符来描述，如一个定义为`java. Lang. String[][]`类型的二维数组将被记录成`[[Ljava/lang/String；`，一个整型数组`int[]`将被记录成`[I`。

用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号之内。如方法 `void inc()` 的描述符为“ `()V` ”，方法 `java.lang.String toString()` 的描述符为“ `() Ljava/lang/String；` ”，方法 `int indexOf(char[] source，int sourceOffset，int sourceCount，char[] target， int targetOffset，int targetCount，int fromIndex)` 的描述符为“ `([CII[CIII)I` ”。

# 方法表

```c
`method_info` {
    u2              access_flags;
    u2              name_index;
    u2              descriptor_index;
    u2              attributes_count;
    attribute_info  attributes[attributes_count];
}
```

Class 文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags） 、名称索引（name_index） 、描述符索引（descriptor_index） 、属性表集合（attributes） 几项。

在访问标志和属性表集合的可选项中有所区别，因为 volatile 关键字和 transient 关键字不能修饰方法，所以方法表的访问标志中没有了 `ACC_VOLATILE` 标志和 `ACC_TRANSIENT` 标志。与之相对， synchronized、 native、 strictfp 和 abstract 关键字可以修饰方法，方法表的访问标志中也相应地增加了 `ACC_SYNCHRONIZED`、`ACC_NATIVE`、 `ACC_STRICT` 和 `ACC_ABSTRACT` 标志。

# 属性表


```c
attribute_info {
    u2  attribute_name_index;
    u4  attribute_length;
    u1  info[attribute_length];
}
```

与 Class 文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java 虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。为了能正确解析 Class 文件，《Java 虚拟机规范》最初只预定义了 9 项所有 Java 虚拟机实现都应当能识别的属性，而在最新的《Java 虚拟机规范》的 Java SE 12 版本中，预定义属性已经增加到 29 项。

JVM 1.8 标准列出了这些预定义属性项 ( 一共 23 中 ) 出现在类文件结构中的所有情形。如果没有规定条件，就说明相应的属性在属性表中的使用没有限制。

所有预定义属性项根据其用途可以分成 3 组：

1. 以下 5 个属性项对 Java 虚拟机正确解读类文件中的信息至关重要。

- ConstantValue
- Code
- StackMapTable
- Exceptions
- BootstrapMethods

2. 有 12 个属性项与 Java 平台类库解析类文件有关。

- InnerClasses
- EnclosingMethod
- Synthetic
- Signature
- RuntimeVisibleAnnotations
- RuntimeInvisibleAnnotations
- RuntimeVisibleParameterAnnotations
- RuntimeInvisibleParameterAnnotations
- RuntimeVisibleTypeAnnotations
- RuntimeInvisibleTypeAnnotations
- AnnotationDefault
- MethodParameters

3. 还有 6 个属性项与虚拟机解读类文件的过程无关，也和 Java 类库无关。但它们对一些第三方工具有用。

- SourceFile
- SourceDebugExtension
- LineNumberTable
- LocalVariableTable
- LocalVariableTypeTable
- Deprecated

对于每一个属性，它的名称都要从常量池中引用一个 `CONSTANT_Utf8_info` 类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个 u4 的长度属性去说明属性值所占用的位数即可。属性表中一个属性项的基本结构如下。

```c
attribute_info {
    u2  attribute_name_index;
    u4  attribute_length;
    u1  info[attribute_length];
}
```

// TODO 周志明《深入理解 Java 虚拟机》 6.3.7 属性表集合 Page 321

[java class文件详解 - 一寸HUI - 博客园](https://www.cnblogs.com/zsql/p/12907120.html): https://www.cnblogs.com/zsql/p/12907120.html

## 1. code 属性

方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了？ 方法里的 Java 代码，经过 javac 编译器编译成字节码指令之后，存放在方法属性表集合中一个名为`Code`的属性里面，属性表作为 Class 文件格式中最具扩展性的一种数据项目，

Java 程序方法体里面的代码经过 Javac 编译器处理之后，最终变为字节码指令存储在 `Code` 属性内。`Code` 属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在 `Code` 属性。

`Code` 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码（`Code`，方法体里面的 Java 代码） 和元数据（Metadata，包括类、字段、方法定义及其他信息） 两部分，那么在整个 Class 文件里， `Code` 属性用于描述代码，所有的其他数据项目都用于描述元数据。

## 2. Exceptions 属性

Exceptions 属性的作用是列举出方法中可能抛出的受查异常（Checked Exceptions） ，也就是方法描述时在 throws 关键字后面列举的异常。

## 3. `LineNumberTable` 属性

`LineNumberTable` 属性用于描述 Java 源码行号与字节码行号（字节码的偏移量） 之间的对应关系。并不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 Javac 中使用 `-g:none` 或 `-g:lines` 选项来取消或要求生成这项信息。

## 4.  `LocalVariableTable` 及 `LocalVariableTypeTable` 属性

`LocalVariableTable` 属性用于描述栈帧中局部变量表的变量与 Java 源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 javac 中使用 `-g:none` 或 `-g:vars` 选项来取消或要求生成这项信息

## 5.  `SourceFile` 及 `SourceDebugExtension` 属性

`SourceFile` 属性用于记录生成这个 Class 文件的源码文件名称。这个属性也是可选的，可以使用 Javac 的 `-g: none` 或 `-g:source` 选项来关闭或要求生成这项信息。在 Java 中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类） 例外

`SourceDebugExtension` 属性用于存储额外的代码调试信息。典型的场景是在进行 JSP 文件调试时，无法通过 Java 堆栈来定位到 JSP 文件的行号。

## 6.  `ConstantValue` 属性

`ConstantValue` 属性的作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量） 才可以使用这项属性。类似“`int x=123`”和“`static int x=123`”这样的变量定义在 Java 程序里面是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对非 static 类型的变量（也就是实例变量） 的赋值是在实例构造器`<init>()` 方法中进行的；而对于类变量，则有两种方式可以选择： 在类构造器`<clinit>()` 方法中或者使用 `ConstantValue` 属性。

## 7.  `InnerClasses` 属性

`InnerClasses` 属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成 `InnerClasses` 属性

## 8.  `Deprecated` 及 `Synthetic` 属性

`Deprecated` 和 `Synthetic` 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。

`Deprecated` 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“`@deprecated`”注解进行设置

`Synthetic` 属性代表此字段或者方法并不是由 Java 源码直接产生的，而是由编译器自行添加的，在 JDK 5 之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 `ACC_SYNTHETIC` 标志位。

## 9. `StackMapTable` 属性

`StackMapTable` 是一个相当复杂的变长属性，位于 `Code` 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（TypeChecker），目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。

`StackMapTable` 属性中包含零至多个栈映射帧（Stack Map Frame） ，每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。

## 10. `Signature` 属性

`Signature` 属性是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable） 或参数化类型（ParameterizedType） ，则 `Signature` 属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为 Java 语言的泛型采用的是擦除法实现的伪泛型，字节码（`Code` 属性） 中所有的泛型信息编译（类型变量、参数化类型） 在编译之后都通通被擦除掉。

## 11. `BootstrapMethods` 属性

`BootstrapMethods` 是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存 invokedynamic 指令引用的引导方法限定符。

## 12. `MethodParameters` 属性

`MethodParameters` 是一个用在方法表中的变长属性。`MethodParameters` 的作用是记录方法的各个形参名称和信息。

## 13. 模块化相关属性

JDK 9 的一个重量级功能是 Java 的模块化功能，因为模块描述文件（`module-info.java`） 最终是要编译成一个独立的 Class 文件来存储的，所以， Class 文件格式也扩展了 `Module` 、 `ModulePackages` 和 `ModuleMainClass` 三个属性用于支持 Java 模块化相关功能。

Module 属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块 requires、 exports、 opens、 uses 和 provides 定义的全部内容，

`ModulePackages` 是另一个用于支持 Java 模块化的变长属性，它用于描述该模块中所有的包，不论是不是被 export 或者 open 的。

`ModuleMainClass` 属性是一个定长属性，用于确定该模块的主类（Main Class）


# 总体结构

通过一段读取类文件的代码来总结一下类文件结构，加深理解。整个 Class 文件的解析主要在 `ClassFile` 这个类中，它的包名为 `com.sun.tools.classfile` 。

```java
`ClassFile`(InputStream in, Attribute.Factory attributeFactory) throws IOException, ConstantPoolException {
        ClassReader cr = new ClassReader(this, in, attributeFactory);
        //魔幻数
        magic = cr.readInt();
        //版本号        
        minor_version = cr.readUnsignedShort();
        major_version = cr.readUnsignedShort();
        //常量池
        constant_pool = new ConstantPool(cr);
        access_flags = new AccessFlags(cr);
        this_class = cr.readUnsignedShort();
        super_class = cr.readUnsignedShort();
        //接口信息
        int interfaces_count = cr.readUnsignedShort();
        interfaces = new int[interfaces_count];
        for (int i = 0; i < interfaces_count; i++)
            interfaces[i] = cr.readUnsignedShort();
        //字段信息
        int fields_count = cr.readUnsignedShort();
        fields = new Field[fields_count];
        for (int i = 0; i < fields_count; i++)
            fields[i] = new Field(cr);
        //方法信息
        int methods_count = cr.readUnsignedShort();
        methods = new Method[methods_count];
        for (int i = 0; i < methods_count; i++)
            methods[i] = new Method(cr);
        //属性信息
        attributes = new Attributes(cr);
    }
```

# 附录

- JVM 1.8 的类和方法、字段的访问标志、属性项：[ClassLayout](ClassLayout.md)
- [java class文件详解 - 一寸HUI - 博客园](https://www.cnblogs.com/zsql/p/12907120.html): https://www.cnblogs.com/zsql/p/12907120.html
- [Java Class文件格式详解 - 腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1816694): https://cloud.tencent.com/developer/article/1816694

